# Введение

## Функциональное программирование на практике

Идеи функционального программирования давно проникли в мейнстрим. Вы наверняка пользовались `map`, `filter` и `reduce` в Python, JavaScript или Java. Вы видели, как React строит интерфейсы из чистых функций, а Redux управляет состоянием через редьюсеры. Стримы в Java 8+, LINQ в C#, паттерн-матчинг в Rust -- все это заимствования из мира функциональных языков.

Но в языках общего назначения функциональные техники остаются надстройкой: ничто не мешает обойти их, мутировать состояние или бросить исключение в произвольном месте. OCaml предлагает другой путь. Он делает функциональный подход *основой* языка, при этом оставаясь прагматичным:

- **Строгая статическая типизация.** Компилятор отлавливает целые классы ошибок до запуска программы. Если код скомпилировался -- в нем нет ошибок типов, нет `null pointer exception`, нет несовпадения аргументов.
- **Мощный вывод типов (type inference).** Вам редко придется писать типы вручную -- компилятор выводит их сам. При этом типы в OCaml гораздо выразительнее, чем в большинстве промышленных языков.
- **Прямые эффекты (direct effects).** В отличие от Haskell, OCaml не требует монады `IO` для побочных эффектов. Вы пишете код в естественном, прямом стиле -- и при этом можете структурировать эффекты, когда это действительно нужно.

Результат -- код, который легко писать, легко читать и легко рефакторить.

## Почему OCaml

OCaml существует с 1996 года (а его предшественник Caml -- с 1985-го). За это время он из академического проекта INRIA превратился в язык с развитой экосистемой и серьезными промышленными применениями:

- **Финтех.** Jane Street -- одна из крупнейших проприетарных трейдинговых фирм в мире -- использует OCaml как основной язык разработки. Миллионы строк OCaml-кода обрабатывают торговые операции на миллиарды долларов ежедневно. Bloomberg применяет OCaml для финансовой аналитики.
- **Блокчейн.** Tezos -- блокчейн-платформа с формально верифицированными смарт-контрактами -- написана на OCaml.
- **Инструменты разработчика.** Meta (Facebook) создала на OCaml систему типов Flow для JavaScript и статический анализатор Infer, который находит ошибки в коде Android и iOS приложений. Компилятор Reason, Hack -- все это OCaml.
- **Системное программирование.** MirageOS -- unikernel-фреймворк для создания минималистичных операционных систем -- написан на OCaml. Docker for Mac и Docker for Windows используют компоненты на OCaml.

OCaml -- не самый популярный язык по количеству вакансий. Но компании, которые его используют, как правило, решают сложные задачи, где надежность и корректность кода критически важны.

## Философия языка

Три столпа OCaml:

### Строгая типизация

Система типов OCaml -- одна из самых выразительных среди практических языков программирования. Она не просто отлавливает ошибки на этапе компиляции, но и служит языком проектирования:

```text
# let safe_head = function
    | [] -> None
    | x :: _ -> Some x;;
val safe_head : 'a list -> 'a option = <fun>
```

Тип `'a option` кодирует возможность отсутствия результата прямо в типе -- не нужен `null`, не нужны исключения для штатных ситуаций. Компилятор заставит вас обработать оба случая. А полиморфная переменная `'a` означает, что функция работает со списком *любого* типа.

### Вывод типов

OCaml использует алгоритм Хиндли--Милнера (Hindley--Milner), который выводит наиболее общий тип выражения автоматически. Вам почти никогда не нужно писать аннотации типов:

```text
# let compose f g x = f (g x);;
val compose : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
```

Компилятор сам понял, что `compose` принимает две функции и значение, и вывел самый общий тип. Вы получаете гарантии строгой типизации практически бесплатно -- без многословных аннотаций, привычных по Java или C#.

### Прямые эффекты

В отличие от Haskell, где побочные эффекты изолированы в монаде `IO`, OCaml позволяет выполнять эффекты напрямую:

```text
# print_endline "Привет, мир!";;
Привет, мир!
- : unit = ()
```

Функция с побочным эффектом -- это обычная функция, возвращающая `unit`. Это делает OCaml более прагматичным: вы пишете код в прямом стиле, без необходимости оборачивать каждое действие в монадическую цепочку. При этом OCaml 5 предлагает систему обработчиков эффектов (effect handlers) для тех случаев, когда структурирование эффектов действительно необходимо -- мы рассмотрим их в главе 11.

## OCaml 5 и многоядерность

В 2022 году вышел OCaml 5.0 -- важнейшее обновление языка за последние десятилетия. Оно принесло два ключевых нововведения:

- **Домены (domains)** -- настоящий параллелизм на нескольких ядрах процессора. До OCaml 5 рантайм использовал глобальную блокировку (GIL), подобно Python и Ruby.
- **Обработчики эффектов (effect handlers)** -- механизм структурированной конкурентности, позволяющий писать асинхронный код в прямом стиле, без коллбэков и промисов.

Эта книга использует OCaml 5 и активно применяет его возможности, особенно в главах 9 (конкурентность с Eio) и 11 (обработчики эффектов).

## OCaml среди других ФП-языков

Если вы уже знакомы с функциональным программированием, вот как OCaml соотносится с другими языками:

| Язык | Типизация | Вычисления | Рантайм | Особенность |
|------|-----------|------------|---------|-------------|
| **OCaml** | Статическая, строгая | Строгие | Нативный код | Модули первого класса, effect handlers |
| **Haskell** | Статическая, строгая | Ленивые | Нативный код | Чистота по умолчанию |
| **F#** | Статическая, строгая | Строгие | .NET | Совместимость с .NET экосистемой |
| **Scala** | Статическая, строгая | Строгие | JVM | Совместимость с Java |
| **Rust** | Статическая, строгая | Строгие | Нативный код | Ownership, без сборщика мусора |
| **Elixir** | Динамическая | Строгие | BEAM | Акторная модель, отказоустойчивость |
| **Clojure** | Динамическая | Строгие | JVM | Лисп, иммутабельные структуры |

Главные отличия OCaml -- **модульная система с функторами**, **компиляция в эффективный нативный код** и начиная с версии 5 -- **встроенная многоядерность и обработчики эффектов**. По производительности OCaml стабильно входит в число самых быстрых функциональных языков, конкурируя с Haskell и приближаясь к C.

## О чем эта книга

Эта книга -- практическое руководство по OCaml. Каждая глава строится вокруг конкретного проекта: адресная книга, виртуальная файловая система, текстовая RPG-игра, парсер выражений. Теория вводится ровно в том объеме, который нужен для решения задачи.

Книга основана на структуре [PureScript by Example](https://book.purescript.org/) Фила Фримена и является адаптацией параллельной версии для Haskell. Примеры переписаны с нуля для идиоматического OCaml, а концепции, специфичные для Haskell (монады, ленивость, классы типов), заменены на OCaml-эквиваленты (прямые эффекты, модульная система, функторы).

**Что вам понадобится:**

- Базовое знание программирования на любом языке.
- Опыт функционального программирования не обязателен, но не помешает.
- Готовность работать в командной строке.

**Что вы изучите:**

- Алгебраические типы данных и сопоставление с образцом (pattern matching).
- Функции высшего порядка, свертки и рекурсию.
- Модульную систему OCaml: модули, сигнатуры, функторы.
- Обработку ошибок через `option`, `result` и let-операторы.
- Мутабельное состояние и прямые эффекты.
- Конкурентное программирование с Eio.
- FFI -- взаимодействие с C.
- Обработчики эффектов (effect handlers) в OCaml 5.
- Генеративное тестирование с QCheck.
- Парсер-комбинаторы и обобщенные алгебраические типы данных (GADT).

## Как читать эту книгу

Главы выстроены последовательно -- каждая опирается на предыдущие. Если вы новичок в функциональном программировании, рекомендуем читать по порядку. Если у вас есть опыт с OCaml или ML-подобными языками, вы можете перейти к интересующей теме, возвращаясь к ранним главам при необходимости.

Каждая глава (начиная со второй) содержит упражнения. Настоятельно рекомендуем их выполнять -- именно в практике закрепляется понимание. Код упражнений доступен в репозитории книги, и для каждой главы есть:

- **`lib/`** -- исходный код примеров и вспомогательные модули.
- **`test/`** -- тесты, которые проверят ваши решения.
- **`test/my_solutions.ml`** -- файл, в который вы пишете свои решения.
- **`no-peeking/solutions.ml`** -- эталонные решения (загляните, только если застряли).

Примеры кода выглядят так:

```ocaml
let () =
  print_endline "Привет, мир!"
```

Команды, которые нужно ввести в терминале, начинаются с символа `$`:

```text
$ dune build
```

Команды для utop (интерактивного интерпретатора) начинаются с `#`:

```text
# List.map (fun x -> x * 2) [1; 2; 3];;
- : int list = [2; 4; 6]

# #show List.map;;
val map : ('a -> 'b) -> 'a list -> 'b list
```

Чтобы проверить свои решения, выполните из каталога упражнений:

```text
$ dune runtest
```

## Где искать помощь

Если вы застрянете, вот полезные ресурсы:

- [OCaml.org](https://ocaml.org/) -- официальный сайт с документацией, туториалами и новостями.
- [Real World OCaml (2nd ed.)](https://dev.realworldocaml.org/) -- подробная книга от разработчиков Jane Street. Отличный справочник по экосистеме.
- [OCaml Manual](https://v2.ocaml.org/manual/) -- официальная документация языка и стандартной библиотеки.
- [Cornell CS 3110 -- OCaml Programming](https://cs3110.github.io/textbook/) -- отличный университетский курс с упражнениями, доступный бесплатно онлайн.
- [OCaml Discuss](https://discuss.ocaml.org/) -- форум сообщества. Хорошее место, чтобы задать вопрос и получить ответ от опытных разработчиков.

## Благодарности

Эта книга вдохновлена работой Фила Фримена (Phil Freeman) -- автора PureScript и книги "PureScript by Example", которая послужила основой для структуры и подхода. Спасибо всем контрибьюторам экосистемы OCaml, без которых этот язык не стал бы тем, чем он является сегодня.
