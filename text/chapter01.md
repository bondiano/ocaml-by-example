# Введение

## Зачем OCaml, если есть Python и TypeScript?

В Python пишешь `data["key"]` — и получаешь `KeyError` в рантайме. В TypeScript компилятор пропускает `undefined`, браузер падает уже у пользователя. Mypy и `strict` помогают, но не закрывают дыры: `any` пролезает незаметно, аннотации можно пропустить.

OCaml устроен иначе. Система типов не позволяет проигнорировать неопределённость — нужно обработать её явно:

- **Строгая статическая типизация.** Компилятор отлавливает целые классы ошибок до запуска программы. Если код скомпилировался — в нем нет ошибок типов, нет `null pointer exception`, нет несовпадения аргументов. Это как TypeScript strict mode, но встроенный в язык с первого дня.
- **Мощный вывод типов.** Вам редко придётся писать типы вручную — компилятор выводит их сам. Представьте mypy, который работает без аннотаций и никогда не ошибается.
- **Прямые эффекты.** Вы пишете `print_endline "hello"` — и оно работает. Никаких `async/await`, `IO` монад или оборачиваний. OCaml прагматичен: функциональный по умолчанию, но без пуризма.

Результат — код, который легко писать, легко читать и легко рефакторить.

## Почему OCaml

OCaml существует с 1996 года (а его предшественник Caml — с 1985-го). За это время он из академического проекта INRIA превратился в язык с развитой экосистемой и серьезными промышленными применениями:

- **Финтех.** Jane Street — одна из крупнейших проприетарных трейдинговых фирм в мире — использует OCaml как основной язык разработки. Миллионы строк OCaml-кода обрабатывают торговые операции на миллиарды долларов ежедневно. Bloomberg применяет OCaml для финансовой аналитики.
- **Блокчейн.** Tezos — блокчейн-платформа с формально верифицированными смарт-контрактами — написана на OCaml.
- **Инструменты разработчика.** Meta (Facebook) создала на OCaml систему типов Flow для JavaScript и статический анализатор Infer, который находит ошибки в коде Android и iOS приложений. Компилятор Reason, Hack — все это OCaml.
- **Системное программирование.** MirageOS — unikernel-фреймворк для создания минималистичных операционных систем — написан на OCaml. Docker for Mac и Docker for Windows используют компоненты на OCaml.

OCaml — не самый популярный язык по количеству вакансий. Но компании, которые его используют, как правило, решают сложные задачи, где надежность и корректность кода критически важны.

## Философия языка

Три столпа OCaml:

### Строгая типизация

Система типов OCaml — одна из самых выразительных среди практических языков программирования. Она не просто отлавливает ошибки на этапе компиляции, но и служит языком проектирования:

```text
# let safe_head = function
    | [] -> None
    | x :: _ -> Some x;;
val safe_head : 'a list -> 'a option = <fun>
```

Тип `'a option` кодирует возможность отсутствия результата прямо в типе — не нужен `null`, не нужны исключения для штатных ситуаций. Компилятор заставит вас обработать оба случая. А полиморфная переменная `'a` означает, что функция работает со списком *любого* типа.

### Вывод типов

OCaml использует алгоритм Хиндли--Милнера (Hindley--Milner), который выводит наиболее общий тип выражения автоматически. Вам почти никогда не нужно писать аннотации типов:

```text
# let compose f g x = f (g x);;
val compose : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
```

Компилятор сам понял, что `compose` принимает две функции и значение, и вывел самый общий тип. Переменные с апострофом `'a`, `'b`, `'c` — это **полиморфные переменные типов**: они означают «любой тип». Компилятор видит, что `g` принимает `'c` и возвращает `'a`, а `f` принимает `'a` и возвращает `'b`, поэтому результат `compose f g` — это функция `'c -> 'b`.

Вы получаете гарантии строгой типизации практически бесплатно — без многословных аннотаций, привычных по Java или C#.

### Прямые эффекты

В отличие от Haskell, где побочные эффекты изолированы в монаде `IO`, OCaml позволяет выполнять эффекты напрямую:

```text
# print_endline "Привет, мир!";;
Привет, мир!
- : unit = ()
```

Функция с побочным эффектом — это обычная функция, возвращающая `unit`. Это делает OCaml более прагматичным: вы пишете код в прямом стиле, без необходимости оборачивать каждое действие в монадическую цепочку. При этом OCaml 5 предлагает систему обработчиков эффектов (effect handlers) для тех случаев, когда структурирование эффектов действительно необходимо — мы рассмотрим их в главе 13.

## OCaml 5 и многоядерность

В 2022 году вышел OCaml 5.0 — важнейшее обновление языка за последние десятилетия. Оно принесло два ключевых нововведения:

- **Домены (domains)** — настоящий параллелизм на нескольких ядрах процессора. До OCaml 5 рантайм использовал глобальную блокировку (GIL), подобно Python и Ruby.
- **Обработчики эффектов (effect handlers)** — механизм структурированной конкурентности, позволяющий писать асинхронный код в прямом стиле, без коллбэков и промисов.

Эта книга использует **OCaml 5.4.0** и активно применяет его возможности, особенно в главах 12 (конкурентность с Eio) и 13 (обработчики эффектов).

## OCaml среди других языков

Вот как OCaml соотносится с языками, которые вы, возможно, уже знаете:

| Язык | Типизация | Вывод типов | GC | Конкурентность | Скорость компиляции |
|------|-----------|-------------|-----|----------------|---------------------|
| **OCaml** | Статическая, строгая | Полный | Да | Domains + Effects | Быстрая |
| **Python** | Динамическая | Нет | Да | GIL, asyncio | Интерпретатор |
| **TypeScript** | Статическая, gradual | Частичный | Да (JS) | Event loop | Средняя |
| **Go** | Статическая | Частичный | Да | Goroutines | Быстрая |
| **Rust** | Статическая, строгая | Частичный | Нет | async/await + threads | Медленная |
| **Haskell** | Статическая, строгая | Полный | Да | STM + async | Средняя |

Главные отличия OCaml — **полный вывод типов** (как Haskell, но без монад), **модульная система с функторами**, **компиляция в эффективный нативный код** и начиная с версии 5 — **встроенная многоядерность и обработчики эффектов**. По производительности OCaml стабильно входит в число самых быстрых языков с GC, значительно опережая Python и TypeScript.

```admonish note title="Для знатоков Haskell"
OCaml и Haskell — ближайшие родственники в семье ML-языков, но с принципиально разными философиями. Haskell выбирает чистоту (все эффекты в `IO`), ленивость и классы типов. OCaml выбирает прагматизм: прямые эффекты, строгие вычисления и модульную систему вместо классов типов. Оба подхода имеют свои сильные стороны — эта книга покажет, как OCaml решает задачи, которые в Haskell требуют монадических трансформеров.
```

## О чем эта книга

Эта книга — практическое руководство по OCaml. Каждая глава строится вокруг конкретного проекта: адресная книга, виртуальная файловая система, текстовая RPG-игра, парсер выражений. Теория вводится ровно в том объеме, который нужен для решения задачи.

Книга основана на структуре [PureScript by Example](https://book.purescript.org/) Фила Фримена. Примеры переписаны с нуля для идиоматического OCaml, а концепции, специфичные для PureScript, заменены на OCaml-эквиваленты.

**Что вам понадобится:**

- Базовое знание программирования на любом языке.
- Опыт функционального программирования не обязателен, но не помешает.
- Готовность работать в командной строке.

**Что вы изучите:**

- Алгебраические типы данных и сопоставление с образцом (pattern matching).
- Функции высшего порядка, свертки и рекурсию.
- Модульную систему OCaml: модули, сигнатуры, функторы.
- Обработку ошибок через `option`, `result` и let-операторы.
- Мутабельное состояние и прямые эффекты.
- Конкурентное программирование с Eio.
- FFI — взаимодействие с C.
- Обработчики эффектов (effect handlers) в OCaml 5.
- Генеративное тестирование с QCheck.
- Парсер-комбинаторы и обобщенные алгебраические типы данных (GADT).

## Как читать эту книгу

Главы выстроены последовательно — каждая опирается на предыдущие. Если вы новичок в функциональном программировании, рекомендуем читать по порядку. Если у вас есть опыт с OCaml или ML-подобными языками, вы можете перейти к интересующей теме, возвращаясь к ранним главам при необходимости.

Каждая глава (начиная со второй) содержит упражнения. Настоятельно рекомендуем их выполнять — именно в практике закрепляется понимание. Код упражнений доступен в репозитории книги, и для каждой главы есть:

- **`lib/`** — исходный код примеров и вспомогательные модули.
- **`test/`** — тесты, которые проверят ваши решения.
- **`test/my_solutions.ml`** — файл, в который вы пишете свои решения.
- **`no-peeking/solutions.ml`** — эталонные решения (загляните, только если застряли).

Примеры кода выглядят так:

```ocaml
let () =
  print_endline "Привет, мир!"
```

Команды, которые нужно ввести в терминале, начинаются с символа `$`:

```text
$ dune build
```

Команды для utop (интерактивного интерпретатора) начинаются с `#`:

```text
# List.map (fun x -> x * 2) [1; 2; 3];;
- : int list = [2; 4; 6]

# #show List.map;;
val map : ('a -> 'b) -> 'a list -> 'b list
```

Чтобы проверить свои решения, выполните из каталога упражнений:

```text
$ dune runtest
```

## Где искать помощь

Если вы застрянете, вот полезные ресурсы:

- [OCaml.org](https://ocaml.org/) — официальный сайт с документацией, туториалами и новостями.
- [Real World OCaml (2nd ed.)](https://dev.realworldocaml.org/) — подробная книга от разработчиков Jane Street. Отличный справочник по экосистеме. Мы будем ссылаться на неё на протяжении всей книги.
- [OCaml Manual](https://v2.ocaml.org/manual/) — официальная документация языка и стандартной библиотеки.
- [Cornell CS 3110 — OCaml Programming](https://cs3110.github.io/textbook/) — отличный университетский курс с упражнениями, доступный бесплатно онлайн.
- [OCaml Discuss](https://discuss.ocaml.org/) — форум сообщества. Хорошее место, чтобы задать вопрос и получить ответ от опытных разработчиков.

## Благодарности

Эта книга вдохновлена работой Фила Фримена (Phil Freeman) — автора PureScript и книги "PureScript by Example", которая послужила основой для структуры и подхода. Спасибо всем контрибьюторам экосистемы OCaml, без которых этот язык не стал бы тем, чем он является сегодня.

Книга создана при помощи ИИ: _Created with AI assistance from Claude (Anthropic)_.
