# Окружение и инструменты

## Цели главы

В этой главе мы настроим окружение для разработки на OCaml, познакомимся с инструментами и решим несколько упражнений, проверяя ответы с помощью тестов.

## Установка окружения

### opam

[opam](https://opam.ocaml.org/) — менеджер пакетов OCaml. Он управляет версиями компилятора, библиотеками и изолированными окружениями (switch). Установите opam, следуя [официальной инструкции](https://opam.ocaml.org/doc/Install.html):

```text
$ bash -c "sh <(curl -fsSL https://opam.ocaml.org/install.sh)"
```

После установки инициализируйте opam:

```text
$ opam init
$ eval $(opam env)
```

Создайте switch (переключатель) — изолированное окружение с конкретной версией компилятора:

```text
$ opam switch create 5.4.0
$ eval $(opam env)
```

Проверьте, что всё работает:

```text
$ ocaml --version
The OCaml toplevel, version 5.4.0

$ opam --version
2.5.0
```

### Dune

**Dune** — система сборки для OCaml. Она обеспечивает быструю инкрементальную компиляцию и удобную организацию проектов. Установите Dune и утилиты для REPL:

```text
$ opam install dune utop alcotest
```

Проверьте версию:

```text
$ dune --version
3.20.2
```

### Редактор

Для работы с OCaml подойдёт любой редактор с поддержкой [ocaml-lsp](https://github.com/ocaml/ocaml-lsp):

- **VS Code** — расширение [OCaml Platform](https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform).
- **Neovim** — через `nvim-lspconfig` + `ocamllsp`.
- **Emacs** — `tuareg-mode` + `lsp-mode` или `eglot`.

Установите языковой сервер:

```text
$ opam install ocaml-lsp-server ocamlformat
```

ocaml-lsp обеспечивает автодополнение, подсказки типов, переход к определению и форматирование кода.

> Для корректной работы ocaml-lsp рекомендуется открывать в редакторе директорию конкретной главы (например, `exercises/chapter02`), а не корень всего репозитория.

## Структура проекта

Откройте директорию `exercises/chapter02`. Вот что в ней находится:

```text
chapter02/
├── dune-project              <- описание проекта
├── lib/
│   ├── dune                  <- конфигурация библиотеки
│   └── euler.ml              <- исходный код примеров
├── test/
│   ├── dune                  <- конфигурация тестов
│   ├── test_chapter02.ml     <- тесты
│   └── my_solutions.ml       <- ваши решения упражнений
└── no-peeking/
    └── solutions.ml          <- эталонные решения (не подсматривать!)
```

### dune-project

Файл `dune-project` описывает проект:

```text
(lang dune 3.0)

(name chapter02)
```

Директива `lang dune 3.0` задаёт версию языка конфигурации Dune. Поле `name` — имя проекта.

### dune-файлы

В каждой директории с исходным кодом лежит файл `dune`, описывающий, что именно нужно собрать.

Библиотека (`lib/dune`):

```text
(library
 (name chapter02))
```

Это описание библиотеки (library) с именем `chapter02`. Все `.ml`-файлы в директории `lib/` автоматически становятся модулями этой библиотеки.

Тесты (`test/dune`):

```text
(test
 (name test_chapter02)
 (libraries chapter02 alcotest))
```

Это описание тестового исполняемого файла. Поле `libraries` перечисляет зависимости: `chapter02` — наша библиотека, `alcotest` — тестовый фреймворк.

### Модули

В OCaml каждый файл `.ml` автоматически является модулем. Имя модуля — это имя файла с заглавной буквы. Файл `euler.ml` в библиотеке `chapter02` создаёт модуль `Chapter02.Euler`.

Чтобы обратиться к функции `answer` из модуля `Euler`, который входит в библиотеку `chapter02`, пишем:

```ocaml
Chapter02.Euler.answer 10
```

Можно также открыть модуль локально:

```ocaml
let open Chapter02.Euler in
answer 10
```

Конструкция `let open M in expr` делает все имена из модуля `M` видимыми внутри `expr` без префикса. За пределами `in`-выражения имена модуля недоступны без квалификатора — это безопасный способ избежать засорения пространства имён.

## Знакомство с utop

**utop** — интерактивный интерпретатор OCaml (REPL). Запустите его из директории `exercises/chapter02`:

```text
$ cd exercises/chapter02
$ dune utop
```

Dune скомпилирует проект и откроет utop с загруженными модулями:

```text
# Chapter02.Euler.answer 10;;
- : int = 23

# Chapter02.Euler.answer 1000;;
- : int = 233168
```

> В примерах utop символ `#` — это приглашение интерпретатора, а `;;` — завершение выражения. Вы вводите строку после `#`, а utop отвечает результатом.

### Полезные директивы utop

| Директива | Действие |
|-----------|----------|
| `#show val_name;;` | Показать тип значения |
| `#show module_name;;` | Показать содержимое модуля |
| `#use "file.ml";;` | Загрузить файл |
| `#quit;;` или Ctrl+D | Выйти из utop |

Попробуйте выполнить следующие команды:

```text
# let x = 42;;
val x : int = 42

# let greeting = "hello";;
val greeting : string = "hello"

# x + 1;;
- : int = 43

# String.length greeting;;
- : int = 5
```

## Базовые типы

В OCaml есть несколько встроенных типов. Познакомимся с ними в utop.

### int — целые числа

```text
# 42;;
- : int = 42

# 2 + 3;;
- : int = 5

# 10 / 3;;
- : int = 3

# 10 mod 3;;
- : int = 1
```

Целочисленное деление `/` отбрасывает остаток. Оператор `mod` возвращает остаток от деления.

### float — числа с плавающей точкой

```text
# 3.14;;
- : float = 3.14

# 2.0 +. 3.0;;
- : float = 5.

# 10.0 /. 3.0;;
- : float = 3.33333333333333326
```

Обратите внимание: для операций с `float` используются **отдельные операторы** с точкой: `+.`, `-.`, `*.`, `/.`. Это принципиальное отличие OCaml от многих других языков — целочисленная и вещественная арифметика строго разделены. Компилятор не выполняет неявных преобразований между `int` и `float`.

Для преобразования между типами используйте функции:

```text
# float_of_int 42;;
- : float = 42.

# int_of_float 3.14;;
- : int = 3
```

Полезные функции из модуля `Float`:

```text
# Float.sqrt 25.0;;
- : float = 5.

# Float.pi;;
- : float = 3.14159265358979312
```

### string — строки

```text
# "hello";;
- : string = "hello"

# "hello" ^ " " ^ "world";;
- : string = "hello world"

# String.length "hello";;
- : int = 5
```

Оператор `^` соединяет строки (конкатенация).

### bool — логические значения

```text
# true;;
- : bool = true

# 3 > 2;;
- : bool = true

# 3 = 3;;
- : bool = true

# true && false;;
- : bool = false

# true || false;;
- : bool = true

# not true;;
- : bool = false
```

Обратите внимание: для проверки равенства в OCaml используется одинарный знак `=`, а не двойной `==`. Оператор `==` существует, но проверяет физическое тождество (ссылочное равенство), а не структурное — в большинстве случаев вам нужен именно `=`.

### char — символы

```text
# 'a';;
- : char = 'a'

# Char.code 'a';;
- : int = 97

# Char.chr 65;;
- : char = 'A'
```

Символы заключаются в одинарные кавычки. Функции `Char.code` и `Char.chr` преобразуют символы в коды и обратно.

### unit — единичный тип

```text
# ();;
- : unit = ()

# print_endline "hello";;
hello
- : unit = ()
```

Тип `unit` имеет единственное значение `()`. Он используется там, где функция не возвращает полезного результата (аналог `void` в C/Java). Функция `print_endline` печатает строку и возвращает `()`.

## Операторы для float

Вернёмся к теме отдельных операторов для вещественных чисел, потому что это частый источник ошибок у новичков.

В OCaml нельзя написать `2.0 + 3.0` — компилятор выдаст ошибку:

```text
# 2.0 + 3.0;;
Error: This expression has type float but an expression of type int was expected
```

Полная таблица арифметических операторов:

| Операция | int | float |
|----------|-----|-------|
| Сложение | `+` | `+.` |
| Вычитание | `-` | `-.` |
| Умножение | `*` | `*.` |
| Деление | `/` | `/.` |
| Возведение в степень | — | `**` |
| Остаток от деления | `mod` | `Float.rem` |

Такое разделение — следствие строгой типизации OCaml. Компилятор всегда точно знает, с каким типом работает каждый оператор, и это помогает избежать целого класса ошибок.

## let-привязки

В OCaml значения привязываются к именам с помощью ключевого слова `let`:

```ocaml
let x = 42
let name = "OCaml"
```

Привязки неизменяемы (immutable) — после объявления значение нельзя изменить.

### Функции

Функции объявляются тем же `let`. Параметры перечисляются через пробел:

```ocaml
let add a b = a + b
let square x = x * x
```

В utop:

```text
# let add a b = a + b;;
val add : int -> int -> int = <fun>

# add 3 4;;
- : int = 7

# let square x = x * x;;
val square : int -> int = <fun>

# square 5;;
- : int = 25
```

Тип `int -> int -> int` читается так: функция принимает два `int` и возвращает `int`. Стрелка `->` разделяет параметры и результат.

### Вложенные let ... in ...

Конструкция `let ... in ...` создаёт локальную привязку, видимую только внутри выражения после `in`:

```text
# let area r =
    let pi = Float.pi in
    pi *. r *. r;;
val area : float -> float = <fun>

# area 10.0;;
- : float = 314.159265358979312
```

Привязка `pi` существует только внутри тела функции `area`. Можно вкладывать несколько `let ... in`:

```text
# let hypotenuse a b =
    let a2 = a *. a in
    let b2 = b *. b in
    Float.sqrt (a2 +. b2);;
val hypotenuse : float -> float -> float = <fun>

# hypotenuse 3.0 4.0;;
- : float = 5.
```

### Рекурсивные функции

Обычные `let`-привязки не могут ссылаться на себя. Для рекурсии используется `let rec`:

```text
# let rec factorial n =
    if n = 0 then 1
    else n * factorial (n - 1);;
val factorial : int -> int = <fun>

# factorial 5;;
- : int = 120
```

Ключевое слово `rec` явно сообщает компилятору, что функция рекурсивна. В отличие от Haskell, где все привязки рекурсивны по умолчанию, в OCaml рекурсию нужно объявлять явно.

## Тестирование с Alcotest

В этой книге мы используем [Alcotest](https://github.com/mirage/alcotest) — тестовый фреймворк для OCaml. Посмотрим на тесты в `test/test_chapter02.ml`:

```ocaml
let euler_tests =
  let open Alcotest in
  [
    test_case "при limit=10 возвращает 23" `Quick (fun () ->
      check int "answer" 23 (Chapter02.Euler.answer 10));
    test_case "при limit=1000 возвращает 233168" `Quick (fun () ->
      check int "answer" 233168 (Chapter02.Euler.answer 1000));
  ]

let () =
  Alcotest.run "Chapter 02"
    [
      ("Euler — сумма кратных", euler_tests);
      ("diagonal", diagonal_tests);
      ...
    ]
```

Разберём структуру:

- `Alcotest.run` — запускает набор тестов. Первый аргумент — имя набора, второй — список групп.
- Каждая группа — пара `("название", список_тестов)`.
- `test_case` — один тест. Аргументы: описание, скорость (`\`Quick`), и функция-тело.
- `check testable description expected actual` — проверяет, что `actual` равно `expected`. Первый аргумент (`int`, `float 1e-9`, `string`, `bool`) задаёт тип сравнения.

Конструкция `let open Alcotest in` открывает модуль `Alcotest` локально, чтобы использовать `test_case` и `check` без префикса.

Запустите тесты:

```text
$ dune test
```

Тесты для `answer` пройдут, а остальные упадут с ошибкой `Failure "todo"` — это ожидаемо, потому что функции в `my_solutions.ml` ещё не реализованы:

```text
[OK]  Euler — сумма кратных  0  при limit=10 возвращает 23.
[OK]  Euler — сумма кратных  1  при limit=1000 возвращает 233168.
[FAIL] diagonal                0  при 3×4 возвращает 5.
```

По мере решения упражнений тесты начнут проходить.

## Решаем вместе: задача Эйлера N1

Прежде чем переходить к упражнениям, разберём пример, который уже реализован в `lib/euler.ml`.

**Задача Эйлера N1:** найти сумму всех натуральных чисел ниже 1000, которые кратны 3 или 5.

```ocaml
let answer limit =
  let rec go acc n =
    if n >= limit then acc
    else if n mod 3 = 0 || n mod 5 = 0 then go (acc + n) (n + 1)
    else go acc (n + 1)
  in
  go 0 1
```

Разберём по частям:

1. **`let answer limit =`** — объявление функции `answer`, принимающей один параметр `limit`. В OCaml тип выводится автоматически: компилятор определит, что `limit` имеет тип `int`, потому что используется с целочисленными операторами.

2. **`let rec go acc n =`** — вспомогательная рекурсивная функция `go` с двумя параметрами: `acc` (аккумулятор — накопленная сумма) и `n` (текущее число). Ключевое слово `rec` необходимо, потому что `go` вызывает сама себя.

3. **`if n >= limit then acc`** — базовый случай рекурсии: если `n` достигло предела, возвращаем накопленную сумму.

4. **`else if n mod 3 = 0 || n mod 5 = 0 then go (acc + n) (n + 1)`** — если `n` делится на 3 или на 5, прибавляем его к аккумулятору и переходим к следующему числу.

5. **`else go acc (n + 1)`** — иначе просто переходим к следующему числу, не меняя аккумулятор.

6. **`in go 0 1`** — конструкция `in` завершает определение `go` и запускает её с начальными значениями: аккумулятор 0, начальное число 1.

Проверим в utop:

```text
# Chapter02.Euler.answer 10;;
- : int = 23

# Chapter02.Euler.answer 1000;;
- : int = 233168
```

Для `limit = 10` числа, кратные 3 или 5: 3, 5, 6, 9. Их сумма: 3 + 5 + 6 + 9 = 23.

## Хвостовая рекурсия

Мы уже видели рекурсивные функции — `factorial`, `collatz_length`, `go` в задаче Эйлера. Но не все формы рекурсии одинаковы. Рассмотрим важную оптимизацию — **хвостовую рекурсию** (tail recursion).

### Проблема стека

При обычной рекурсии каждый вызов функции добавляет фрейм в стек вызовов. Например, для наивной суммы списка:

```ocaml
let rec sum = function
  | [] -> 0
  | hd :: tl -> hd + sum tl
```

Вызов `sum [1; 2; 3]` раскрывается так:

```text
sum [1; 2; 3]
= 1 + sum [2; 3]
= 1 + (2 + sum [3])
= 1 + (2 + (3 + sum []))
= 1 + (2 + (3 + 0))
= 1 + (2 + 3)
= 1 + 5
= 6
```

Каждый вызов `sum` ждёт результата следующего, удерживая свой фрейм в стеке. Для списка из миллиона элементов это миллион фреймов — **stack overflow**.

### Трансформация с аккумулятором

Решение — переписать функцию так, чтобы рекурсивный вызов был **последним действием** (в хвостовой позиции). Компилятор OCaml оптимизирует такие вызовы, переиспользуя текущий фрейм стека:

```ocaml
(* non-tail recursive — растёт стек *)
let rec sum = function
  | [] -> 0
  | hd :: tl -> hd + sum tl

(* tail-recursive с аккумулятором *)
let sum lst =
  let rec loop acc = function
    | [] -> acc
    | hd :: tl -> (loop [@tailcall]) (hd + acc) tl
  in
  loop 0 lst
```

Во второй версии `loop` — хвосторекурсивная: после вызова `loop` ничего не нужно делать с результатом, он и есть ответ. Образец `hd :: tl` деструктурирует список: `hd` — голова (первый элемент), `tl` — хвост (остаток). Аккумулятор `acc` накапливает промежуточный результат — вместо стека вызовов используется единственная переменная.

### Аннотация `[@tailcall]`

Аннотация `[@tailcall]` просит компилятор проверить, что вызов действительно в хвостовой позиции. Если это не так, компилятор выдаст **Warning 51**:

```ocaml
let rec factorial n =
  if n = 0 then 1
  else n * (factorial [@tailcall]) (n - 1)
(* Warning 51: this tail-call annotation is wrong *)
(* потому что factorial (n-1) не в хвостовой позиции — результат умножается на n *)
```

Правильная хвосторекурсивная версия:

```ocaml
let factorial n =
  let rec loop acc = function
    | 0 -> acc
    | n -> (loop [@tailcall]) (acc * n) (n - 1)
  in
  loop 1 n
```

Ключевое слово `function` — это сокращение для `fun x -> match x with`: оно добавляет неявный последний параметр и сразу сопоставляет его с образцами. Здесь `loop acc` принимает два аргумента: явный `acc` и неявный через `function`. Рекурсивный вызов `loop (acc * n) (n - 1)` находится в хвостовой позиции — после него ничего не вычисляется.

### `[@tail_mod_cons]`

Начиная с OCaml 4.14, есть аннотация `[@tail_mod_cons]` для оптимизации конструирования списков:

```ocaml
let[@tail_mod_cons] rec map f = function
  | [] -> []
  | hd :: tl -> f hd :: map f tl
```

Без этой аннотации `map` не хвосторекурсивна, потому что `::` — конструктор, а не хвостовой вызов: после рекурсивного вызова `map f tl` ещё нужно добавить `f hd` в начало списка. С `[@tail_mod_cons]` компилятор оптимизирует конструирование списка, записывая элементы напрямую в уже выделенную ячейку — стек при этом не растёт.

### Конвенции именования

Внутренний рекурсивный helper принято называть:

- `loop` — наиболее общепринятый вариант
- `aux` — от "auxiliary" (вспомогательный)
- `go` — краткий вариант, популярный в Haskell-сообществе

## Упражнения

Решения пишите в файле `test/my_solutions.ml`. После каждого упражнения запускайте `dune test`, чтобы проверить ответ.

1. **(Лёгкое)** Реализуйте функцию `diagonal`, которая вычисляет длину диагонали прямоугольника по двум сторонам. Используйте теорему Пифагора и функцию `Float.sqrt`.

    ```ocaml
    val diagonal : float -> float -> float
    ```

    ```text
    # diagonal 3.0 4.0;;
    - : float = 5.
    ```

    *Подсказка:* не забывайте использовать операторы для `float` — `+.` и `*.`.

2. **(Лёгкое)** Реализуйте функцию `circle_area`, которая вычисляет площадь круга по радиусу. Используйте константу `Float.pi`.

    ```ocaml
    val circle_area : float -> float
    ```

    ```text
    # circle_area 10.0;;
    - : float = 314.159265358979312
    ```

3. **(Среднее)** Реализуйте функцию `collatz_length`, которая возвращает количество шагов в [последовательности Коллатца](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%BE%D1%82%D0%B5%D0%B7%D0%B0_%D0%9A%D0%BE%D0%BB%D0%BB%D0%B0%D1%82%D1%86%D0%B0) до достижения 1.

    Правила последовательности:
    - Если число чётное — делим на 2.
    - Если нечётное — умножаем на 3 и прибавляем 1.
    - Повторяем, пока не получим 1.

    Например, для числа 6: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1 — **8 шагов**.

    ```ocaml
    val collatz_length : int -> int
    ```

    *Подсказка:* используйте `let rec` и конструкцию `if ... then ... else`. Чётность проверяется выражением `n mod 2 = 0`.

4. **(Лёгкое)** Leap Year — определить, является ли год високосным. Год високосный, если делится на 4, но не на 100, или делится на 400.

5. **(Лёгкое)** Space Age — вычислить возраст в годах на данной планете. Земной год = 31557600 секунд.

6. **(Лёгкое)** Difference of Squares — вычислить разность между квадратом суммы и суммой квадратов первых N натуральных чисел.

7. **(Среднее)** Решето Эратосфена — найти все простые числа до заданного предела.

## Конвенции OCaml

В OCaml используется `snake_case` везде, кроме модулей и конструкторов — они с заглавной буквы. Если модуль представляет один тип, этот тип называется `t`. Функции конвертации называются `of_x` / `to_x`. Суффикс `_exn` обозначает функции, бросающие исключение вместо `option`.

Полный список соглашений с примерами — в [приложении «Конвенции OCaml»](appendix_d.md).

## Dune и инструменты

В этой главе мы познакомились с базовой структурой Dune-проекта. Для настройки реальных проектов понадобятся возможности, которые выходят за рамки вводного материала: правила сборки, встраивание ресурсов, профили, watch mode, предупреждения компилятора, LSP.

Подробный справочник — в [приложении «Инструменты OCaml»](appendix_e.md).

## Заключение

В этой главе мы:

- Установили opam, Dune и настроили редактор.
- Познакомились со структурой проекта: `dune-project`, `dune`-файлы, модули.
- Научились пользоваться utop: вычислять выражения, узнавать типы.
- Изучили базовые типы OCaml: `int`, `float`, `string`, `bool`, `char`, `unit`.
- Разобрали отдельные операторы для `float` и `let`-привязки.
- Познакомились с тестированием через Alcotest.
- Познакомились с основными конвенциями OCaml: `snake_case`, `type t`, `_exn`.
- Узнали о системе сборки Dune и доступных инструментах.
- Решили первые упражнения.

В следующих главах будет больше упражнений, и они станут сложнее. Если вы застрянете, загляните в раздел ["Где искать помощь"](chapter01.md#где-искать-помощь) из первой главы.

Когда решите все упражнения, можете сравнить свои ответы с эталонными в `no-peeking/solutions.ml`. Но, пожалуйста, не подсматривайте без честной попытки решить самостоятельно.
