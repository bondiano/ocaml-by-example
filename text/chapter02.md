# Окружение и инструменты

## Цели главы

В этой главе мы настроим окружение для разработки на OCaml, познакомимся с инструментами и решим несколько упражнений, проверяя ответы с помощью тестов.

## Установка окружения

### opam

[opam](https://opam.ocaml.org/) — менеджер пакетов OCaml. Он управляет версиями компилятора, библиотеками и изолированными окружениями (switch). Установите opam, следуя [официальной инструкции](https://opam.ocaml.org/doc/Install.html):

```text
$ bash -c "sh <(curl -fsSL https://opam.ocaml.org/install.sh)"
```

После установки инициализируйте opam:

```text
$ opam init
$ eval $(opam env)
```

Создайте switch (переключатель) --- изолированное окружение с конкретной версией компилятора:

```text
$ opam switch create 5.4.0
$ eval $(opam env)
```

Проверьте, что всё работает:

```text
$ ocaml --version
The OCaml toplevel, version 5.4.0

$ opam --version
2.5.0
```

### Dune

**Dune** --- система сборки для OCaml. Она обеспечивает быструю инкрементальную компиляцию и удобную организацию проектов. Установите Dune и утилиты для REPL:

```text
$ opam install dune utop alcotest
```

Проверьте версию:

```text
$ dune --version
3.20.2
```

### Редактор

Для работы с OCaml подойдёт любой редактор с поддержкой [ocaml-lsp](https://github.com/ocaml/ocaml-lsp):

- **VS Code** --- расширение [OCaml Platform](https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform).
- **Neovim** --- через `nvim-lspconfig` + `ocamllsp`.
- **Emacs** --- `tuareg-mode` + `lsp-mode` или `eglot`.

Установите языковой сервер:

```text
$ opam install ocaml-lsp-server ocamlformat
```

ocaml-lsp обеспечивает автодополнение, подсказки типов, переход к определению и форматирование кода.

> Для корректной работы ocaml-lsp рекомендуется открывать в редакторе директорию конкретной главы (например, `exercises/chapter02`), а не корень всего репозитория.

## Структура проекта

Откройте директорию `exercises/chapter02`. Вот что в ней находится:

```text
chapter02/
├── dune-project              <- описание проекта
├── lib/
│   ├── dune                  <- конфигурация библиотеки
│   └── euler.ml              <- исходный код примеров
├── test/
│   ├── dune                  <- конфигурация тестов
│   ├── test_chapter02.ml     <- тесты
│   └── my_solutions.ml       <- ваши решения упражнений
└── no-peeking/
    └── solutions.ml          <- эталонные решения (не подсматривать!)
```

### dune-project

Файл `dune-project` описывает проект:

```text
(lang dune 3.0)

(name chapter02)
```

Директива `lang dune 3.0` задаёт версию языка конфигурации Dune. Поле `name` --- имя проекта.

### dune-файлы

В каждой директории с исходным кодом лежит файл `dune`, описывающий, что именно нужно собрать.

Библиотека (`lib/dune`):

```text
(library
 (name chapter02))
```

Это описание библиотеки (library) с именем `chapter02`. Все `.ml`-файлы в директории `lib/` автоматически становятся модулями этой библиотеки.

Тесты (`test/dune`):

```text
(test
 (name test_chapter02)
 (libraries chapter02 alcotest))
```

Это описание тестового исполняемого файла. Поле `libraries` перечисляет зависимости: `chapter02` --- наша библиотека, `alcotest` --- тестовый фреймворк.

### Модули

В OCaml каждый файл `.ml` автоматически является модулем. Имя модуля --- это имя файла с заглавной буквы. Файл `euler.ml` в библиотеке `chapter02` создаёт модуль `Chapter02.Euler`.

Чтобы обратиться к функции `answer` из модуля `Euler`, который входит в библиотеку `chapter02`, пишем:

```ocaml
Chapter02.Euler.answer 10
```

Можно также открыть модуль локально:

```ocaml
let open Chapter02.Euler in
answer 10
```

## Знакомство с utop

**utop** --- интерактивный интерпретатор OCaml (REPL). Запустите его из директории `exercises/chapter02`:

```text
$ cd exercises/chapter02
$ dune utop
```

Dune скомпилирует проект и откроет utop с загруженными модулями:

```text
# Chapter02.Euler.answer 10;;
- : int = 23

# Chapter02.Euler.answer 1000;;
- : int = 233168
```

> В примерах utop символ `#` --- это приглашение интерпретатора, а `;;` --- завершение выражения. Вы вводите строку после `#`, а utop отвечает результатом.

### Полезные директивы utop

| Директива | Действие |
|-----------|----------|
| `#show val_name;;` | Показать тип значения |
| `#show module_name;;` | Показать содержимое модуля |
| `#use "file.ml";;` | Загрузить файл |
| `#quit;;` или Ctrl+D | Выйти из utop |

Попробуйте:

```text
# let x = 42;;
val x : int = 42

# let greeting = "hello";;
val greeting : string = "hello"

# x + 1;;
- : int = 43

# String.length greeting;;
- : int = 5
```

## Базовые типы

В OCaml есть несколько встроенных типов. Познакомимся с ними в utop.

### int --- целые числа

```text
# 42;;
- : int = 42

# 2 + 3;;
- : int = 5

# 10 / 3;;
- : int = 3

# 10 mod 3;;
- : int = 1
```

Целочисленное деление `/` отбрасывает остаток. Оператор `mod` возвращает остаток от деления.

### float --- числа с плавающей точкой

```text
# 3.14;;
- : float = 3.14

# 2.0 +. 3.0;;
- : float = 5.

# 10.0 /. 3.0;;
- : float = 3.33333333333333326
```

Обратите внимание: для операций с `float` используются **отдельные операторы** с точкой: `+.`, `-.`, `*.`, `/.`. Это принципиальное отличие OCaml от многих других языков --- целочисленная и вещественная арифметика строго разделены. Компилятор не выполняет неявных преобразований между `int` и `float`.

Для преобразования между типами используйте функции:

```text
# float_of_int 42;;
- : float = 42.

# int_of_float 3.14;;
- : int = 3
```

Полезные функции из модуля `Float`:

```text
# Float.sqrt 25.0;;
- : float = 5.

# Float.pi;;
- : float = 3.14159265358979312
```

### string --- строки

```text
# "hello";;
- : string = "hello"

# "hello" ^ " " ^ "world";;
- : string = "hello world"

# String.length "hello";;
- : int = 5
```

Оператор `^` соединяет строки (конкатенация).

### bool --- логические значения

```text
# true;;
- : bool = true

# 3 > 2;;
- : bool = true

# 3 = 3;;
- : bool = true

# true && false;;
- : bool = false

# true || false;;
- : bool = true

# not true;;
- : bool = false
```

Обратите внимание: для проверки равенства в OCaml используется одинарный знак `=`, а не двойной `==`. Оператор `==` существует, но проверяет физическое тождество (ссылочное равенство), а не структурное --- в большинстве случаев вам нужен именно `=`.

### char --- символы

```text
# 'a';;
- : char = 'a'

# Char.code 'a';;
- : int = 97

# Char.chr 65;;
- : char = 'A'
```

Символы заключаются в одинарные кавычки. Функции `Char.code` и `Char.chr` преобразуют символы в коды и обратно.

### unit --- единичный тип

```text
# ();;
- : unit = ()

# print_endline "hello";;
hello
- : unit = ()
```

Тип `unit` имеет единственное значение `()`. Он используется там, где функция не возвращает полезного результата (аналог `void` в C/Java). Функция `print_endline` печатает строку и возвращает `()`.

## Операторы для float

Вернёмся к теме отдельных операторов для вещественных чисел, потому что это частый источник ошибок у новичков.

В OCaml нельзя написать `2.0 + 3.0` --- компилятор выдаст ошибку:

```text
# 2.0 + 3.0;;
Error: This expression has type float but an expression of type int was expected
```

Полная таблица арифметических операторов:

| Операция | int | float |
|----------|-----|-------|
| Сложение | `+` | `+.` |
| Вычитание | `-` | `-.` |
| Умножение | `*` | `*.` |
| Деление | `/` | `/.` |
| Возведение в степень | --- | `**` |
| Остаток от деления | `mod` | `Float.rem` |

Такое разделение --- следствие строгой типизации OCaml. Компилятор всегда точно знает, с каким типом работает каждый оператор, и это помогает избежать целого класса ошибок.

## let-привязки

В OCaml значения привязываются к именам с помощью ключевого слова `let`:

```ocaml
let x = 42
let name = "OCaml"
```

Привязки неизменяемы (immutable) --- после объявления значение нельзя изменить.

### Функции

Функции объявляются тем же `let`. Параметры перечисляются через пробел:

```ocaml
let add a b = a + b
let square x = x * x
```

В utop:

```text
# let add a b = a + b;;
val add : int -> int -> int = <fun>

# add 3 4;;
- : int = 7

# let square x = x * x;;
val square : int -> int = <fun>

# square 5;;
- : int = 25
```

Тип `int -> int -> int` читается так: функция принимает два `int` и возвращает `int`. Стрелка `->` разделяет параметры и результат.

### Вложенные let ... in ...

Конструкция `let ... in ...` создаёт локальную привязку, видимую только внутри выражения после `in`:

```text
# let area r =
    let pi = Float.pi in
    pi *. r *. r;;
val area : float -> float = <fun>

# area 10.0;;
- : float = 314.159265358979312
```

Привязка `pi` существует только внутри тела функции `area`. Можно вкладывать несколько `let ... in`:

```text
# let hypotenuse a b =
    let a2 = a *. a in
    let b2 = b *. b in
    Float.sqrt (a2 +. b2);;
val hypotenuse : float -> float -> float = <fun>

# hypotenuse 3.0 4.0;;
- : float = 5.
```

### Рекурсивные функции

Обычные `let`-привязки не могут ссылаться на себя. Для рекурсии используется `let rec`:

```text
# let rec factorial n =
    if n = 0 then 1
    else n * factorial (n - 1);;
val factorial : int -> int = <fun>

# factorial 5;;
- : int = 120
```

Ключевое слово `rec` явно сообщает компилятору, что функция рекурсивна. В отличие от Haskell, где все привязки рекурсивны по умолчанию, в OCaml рекурсию нужно объявлять явно.

## Тестирование с Alcotest

В этой книге мы используем [Alcotest](https://github.com/mirage/alcotest) --- тестовый фреймворк для OCaml. Посмотрим на тесты в `test/test_chapter02.ml`:

```ocaml
let euler_tests =
  let open Alcotest in
  [
    test_case "ниже 10 равна 23" `Quick (fun () ->
      check int "answer 10" 23 (Chapter02.Euler.answer 10));
    test_case "ниже 1000 равна 233168" `Quick (fun () ->
      check int "answer 1000" 233168 (Chapter02.Euler.answer 1000));
  ]

let () =
  Alcotest.run "Chapter 02"
    [
      ("Euler --- сумма кратных", euler_tests);
      ("diagonal", diagonal_tests);
      ...
    ]
```

Разберём структуру:

- `Alcotest.run` --- запускает набор тестов. Первый аргумент --- имя набора, второй --- список групп.
- Каждая группа --- пара `("название", список_тестов)`.
- `test_case` --- один тест. Аргументы: описание, скорость (`\`Quick`), и функция-тело.
- `check testable description expected actual` --- проверяет, что `actual` равно `expected`. Первый аргумент (`int`, `float 1e-9`, `string`, `bool`) задаёт тип сравнения.

Конструкция `let open Alcotest in` открывает модуль `Alcotest` локально, чтобы использовать `test_case` и `check` без префикса.

Запустите тесты:

```text
$ dune test
```

Тесты для `answer` пройдут, а остальные упадут с ошибкой `Failure "todo"` --- это ожидаемо, потому что функции в `my_solutions.ml` ещё не реализованы:

```text
[OK]  Euler --- сумма кратных  0  ниже 10 равна 23.
[OK]  Euler --- сумма кратных  1  ниже 1000 равна 233168.
[FAIL] diagonal                0  диагональ 3×4 равна 5.
```

По мере решения упражнений тесты начнут проходить.

## Решаем вместе: задача Эйлера N1

Прежде чем переходить к упражнениям, разберём пример, который уже реализован в `lib/euler.ml`.

**Задача Эйлера N1:** найти сумму всех натуральных чисел ниже 1000, которые кратны 3 или 5.

```ocaml
let answer limit =
  let rec go acc n =
    if n >= limit then acc
    else if n mod 3 = 0 || n mod 5 = 0 then go (acc + n) (n + 1)
    else go acc (n + 1)
  in
  go 0 1
```

Разберём по частям:

1. **`let answer limit =`** --- объявление функции `answer`, принимающей один параметр `limit`. В OCaml тип выводится автоматически: компилятор определит, что `limit` имеет тип `int`, потому что используется с целочисленными операторами.

2. **`let rec go acc n =`** --- вспомогательная рекурсивная функция `go` с двумя параметрами: `acc` (аккумулятор --- накопленная сумма) и `n` (текущее число). Ключевое слово `rec` необходимо, потому что `go` вызывает сама себя.

3. **`if n >= limit then acc`** --- базовый случай рекурсии: если `n` достигло предела, возвращаем накопленную сумму.

4. **`else if n mod 3 = 0 || n mod 5 = 0 then go (acc + n) (n + 1)`** --- если `n` делится на 3 или на 5, прибавляем его к аккумулятору и переходим к следующему числу.

5. **`else go acc (n + 1)`** --- иначе просто переходим к следующему числу, не меняя аккумулятор.

6. **`in go 0 1`** --- конструкция `in` завершает определение `go` и запускает её с начальными значениями: аккумулятор 0, начальное число 1.

Проверим в utop:

```text
# Chapter02.Euler.answer 10;;
- : int = 23

# Chapter02.Euler.answer 1000;;
- : int = 233168
```

Для `limit = 10` числа, кратные 3 или 5: 3, 5, 6, 9. Их сумма: 3 + 5 + 6 + 9 = 23.

## Хвостовая рекурсия

Мы уже видели рекурсивные функции --- `factorial`, `collatz_length`, `go` в задаче Эйлера. Но не все формы рекурсии одинаковы. Рассмотрим важную оптимизацию --- **хвостовую рекурсию** (tail recursion).

### Проблема стека

При обычной рекурсии каждый вызов функции добавляет фрейм в стек вызовов. Например, для наивной суммы списка:

```ocaml
let rec sum = function
  | [] -> 0
  | hd :: tl -> hd + sum tl
```

Вызов `sum [1; 2; 3]` раскрывается так:

```text
sum [1; 2; 3]
= 1 + sum [2; 3]
= 1 + (2 + sum [3])
= 1 + (2 + (3 + sum []))
= 1 + (2 + (3 + 0))
= 1 + (2 + 3)
= 1 + 5
= 6
```

Каждый вызов `sum` ждёт результата следующего, удерживая свой фрейм в стеке. Для списка из миллиона элементов это миллион фреймов --- **stack overflow**.

### Трансформация с аккумулятором

Решение --- переписать функцию так, чтобы рекурсивный вызов был **последним действием** (в хвостовой позиции). Компилятор OCaml оптимизирует такие вызовы, переиспользуя текущий фрейм стека:

```ocaml
(* non-tail recursive — растёт стек *)
let rec sum = function
  | [] -> 0
  | hd :: tl -> hd + sum tl

(* tail-recursive с аккумулятором *)
let sum lst =
  let rec loop acc = function
    | [] -> acc
    | hd :: tl -> (loop [@tailcall]) (hd + acc) tl
  in
  loop 0 lst
```

Во второй версии `loop` --- хвосторекурсивная: после вызова `loop` ничего не нужно делать с результатом, он и есть ответ. Аккумулятор `acc` накапливает промежуточный результат.

### Аннотация `[@tailcall]`

Аннотация `[@tailcall]` просит компилятор проверить, что вызов действительно в хвостовой позиции. Если это не так, компилятор выдаст **Warning 51**:

```ocaml
let rec factorial n =
  if n = 0 then 1
  else n * (factorial [@tailcall]) (n - 1)
(* Warning 51: this tail-call annotation is wrong *)
(* потому что factorial (n-1) не в хвостовой позиции — результат умножается на n *)
```

Правильная хвосторекурсивная версия:

```ocaml
let factorial n =
  let rec loop acc = function
    | 0 -> acc
    | n -> (loop [@tailcall]) (acc * n) (n - 1)
  in
  loop 1 n
```

### `[@tail_mod_cons]`

Начиная с OCaml 4.14, есть аннотация `[@tail_mod_cons]` для оптимизации конструирования списков:

```ocaml
let[@tail_mod_cons] rec map f = function
  | [] -> []
  | hd :: tl -> f hd :: map f tl
```

Без этой аннотации `map` не хвосторекурсивна, потому что `::` --- конструктор, а не хвостовой вызов. С `[@tail_mod_cons]` компилятор оптимизирует конструирование списка, записывая элементы напрямую в уже выделенную ячейку.

### Конвенции именования

Внутренний рекурсивный helper принято называть:

- `loop` --- наиболее общепринятый вариант
- `aux` --- от "auxiliary" (вспомогательный)
- `go` --- краткий вариант, популярный в Haskell-сообществе

## Упражнения

Решения пишите в файле `test/my_solutions.ml`. После каждого упражнения запускайте `dune test`, чтобы проверить ответ.

1. **(Лёгкое)** Реализуйте функцию `diagonal`, которая вычисляет длину диагонали прямоугольника по двум сторонам. Используйте теорему Пифагора и функцию `Float.sqrt`.

    ```ocaml
    val diagonal : float -> float -> float
    ```

    ```text
    # diagonal 3.0 4.0;;
    - : float = 5.
    ```

    *Подсказка:* не забывайте использовать операторы для `float` --- `+.` и `*.`.

2. **(Лёгкое)** Реализуйте функцию `circle_area`, которая вычисляет площадь круга по радиусу. Используйте константу `Float.pi`.

    ```ocaml
    val circle_area : float -> float
    ```

    ```text
    # circle_area 10.0;;
    - : float = 314.159265358979312
    ```

3. **(Среднее)** Реализуйте функцию `collatz_length`, которая возвращает количество шагов в [последовательности Коллатца](https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%BE%D1%82%D0%B5%D0%B7%D0%B0_%D0%9A%D0%BE%D0%BB%D0%BB%D0%B0%D1%82%D1%86%D0%B0) до достижения 1.

    Правила последовательности:
    - Если число чётное --- делим на 2.
    - Если нечётное --- умножаем на 3 и прибавляем 1.
    - Повторяем, пока не получим 1.

    Например, для числа 6: 6 -> 3 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1 --- **8 шагов**.

    ```ocaml
    val collatz_length : int -> int
    ```

    *Подсказка:* используйте `let rec` и конструкцию `if ... then ... else`. Чётность проверяется выражением `n mod 2 = 0`.

4. **(Лёгкое)** Leap Year --- определить, является ли год високосным. Год високосный, если делится на 4, но не на 100, или делится на 400.

5. **(Лёгкое)** Space Age --- вычислить возраст в годах на данной планете. Земной год = 31557600 секунд.

6. **(Лёгкое)** Difference of Squares --- вычислить разность между квадратом суммы и суммой квадратов первых N натуральных чисел.

7. **(Среднее)** Решето Эратосфена --- найти все простые числа до заданного предела.

## Конвенции и гайдлайны OCaml

Прежде чем двигаться дальше, полезно усвоить основные соглашения, принятые в сообществе OCaml. Следование этим конвенциям делает код единообразным и облегчает чтение чужих библиотек.

### Именование

В OCaml используется `snake_case` для всего, кроме модулей и конструкторов (они пишутся с заглавной буквы):

```ocaml
(* Хорошо *)
let max_value = 100
let find_first_match xs = ...

(* Плохо *)
let maxValue = 100
let FindFirstMatch xs = ...
```

**`type t` --- основной тип в модуле.** По конвенции, если модуль представляет один тип, этот тип называется `t`:

```ocaml
module User = struct
  type t = {
    name : string;
    age : int;
  }

  let create name age = { name; age }
end
```

**Конструкторы: `create`, `make`, `init`** --- у каждого своя семантика:

- `create` --- аллокация без инициализации содержимого:

```ocaml
let buf = Bytes.create 10
(* 10 байт, содержимое не определено *)
```

- `make` --- инициализация одним значением:

```ocaml
let arr = Array.make 3 "x"
(* [| "x"; "x"; "x" |] *)
```

- `init` --- инициализация функцией от индекса:

```ocaml
let arr = Array.init 3 (Printf.sprintf "x%d")
(* [| "x0"; "x1"; "x2" |] *)
```

**`of_x` / `to_x` --- конвертация** между типами:

```ocaml
let s = String.of_seq (List.to_seq ['h'; 'i'])
(* "hi" *)

let n = int_of_string "42"
let s = string_of_int 42
```

**Суффикс `_exn`** обозначает функции, которые бросают исключения вместо возврата `option` или `result`. В стандартной библиотеке эта конвенция соблюдается не везде --- некоторые старые функции бросают исключения без суффикса:

```ocaml
(* Stdlib: find_opt возвращает option, find бросает исключение (без _exn) *)
let x = List.find_opt (fun n -> n > 10) [1; 5; 20]
(* Some 20 *)
let y = List.find (fun n -> n > 10) [1; 2; 3]
(* Exception: Not_found *)

(* Конвенция _exn: int_of_string_opt / int_of_string *)
let a = int_of_string_opt "abc"   (* None *)
let b = int_of_string "abc"       (* Exception: Failure "int_of_string" *)

(* В библиотеках Base/Core суффикс _exn используется последовательно:
   List.find      : 'a list -> f:('a -> bool) -> 'a option
   List.find_exn  : 'a list -> f:('a -> bool) -> 'a       *)
```

### Модули

**Каждый значимый тип --- в своём модуле.** Это основная единица организации кода в OCaml:

```ocaml
(* user.ml *)
type t = { name : string; email : string }

let create name email = { name; email }
let to_string u = Printf.sprintf "%s <%s>" u.name u.email
```

**Пишите `.mli` для публичных модулей.** Интерфейсный файл делает API явным и скрывает детали реализации:

```ocaml
(* user.mli *)
type t

val create : string -> string -> t
val to_string : t -> string
```

**Избегайте `open`, используйте qualified names.** Это делает код читаемее --- сразу видно, откуда пришла функция:

```ocaml
(* Хорошо --- видно, что length из String *)
let n = String.length s

(* Хуже --- непонятно, откуда length *)
open String
let n = length s
```

Исключение --- модули, которые существенно переопределяют окружение и предназначены для `open`: `Format`, `Effect.Deep` и подобные.

### Pattern matching

**Не используйте `hd` / `tl` --- только pattern matching:**

```ocaml
(* Хорошо *)
let first_or_default default = function
  | x :: _ -> x
  | [] -> default

(* Плохо *)
let first_or_default default lst =
  if lst = [] then default
  else List.hd lst
```

**Не используйте catch-all `_` на конкретных типах --- перечисляйте все конструкторы.** Это гарантирует, что при добавлении нового конструктора компилятор укажет на все места, которые нужно обновить:

```ocaml
type color = Red | Green | Blue

(* Хорошо --- компилятор предупредит, если добавится Yellow *)
let to_string = function
  | Red -> "red"
  | Green -> "green"
  | Blue -> "blue"

(* Плохо --- добавление Yellow пройдёт незамеченным *)
let to_string = function
  | Red -> "red"
  | _ -> "other"
```

**Все клозы начинаются с `|`, включая первый:**

```ocaml
(* Хорошо *)
let describe = function
  | 0 -> "zero"
  | 1 -> "one"
  | _ -> "many"

(* Хуже --- первый клоз без | *)
let describe = function
    0 -> "zero"
  | 1 -> "one"
  | _ -> "many"
```

**Не выравнивайте стрелки `->` между клозами:**

```ocaml
(* Хорошо *)
let f = function
  | Some x -> x + 1
  | None -> 0

(* Плохо --- лишние пробелы для выравнивания *)
let f = function
  | Some x -> x + 1
  | None   -> 0
```

### Exceptions vs Result

**Exceptions** --- для действительно исключительных ситуаций и performance-critical путей:

```ocaml
(* Исключение --- программная ошибка, не должно происходить *)
let head = function
  | x :: _ -> x
  | [] -> invalid_arg "head: empty list"

(* Исключение --- для производительности в горячем цикле *)
exception Found of int

let find_index pred arr =
  try
    for i = 0 to Array.length arr - 1 do
      if pred arr.(i) then raise (Found i)
    done;
    None
  with Found i -> Some i
```

**Result** --- для ожидаемых ошибок и composable error handling:

```ocaml
let parse_int s =
  match int_of_string_opt s with
  | Some n -> Ok n
  | None -> Error (Printf.sprintf "not an integer: %s" s)

let parse_positive s =
  parse_int s
  |> Result.bind (fun n ->
    if n > 0 then Ok n
    else Error (Printf.sprintf "not positive: %d" n))
```

Суффикс **`_exn`** служит маркером: если есть `find` (возвращает `option`) и `find_exn` (бросает исключение), имя явно предупреждает о поведении.

### Мутабельность

**Immutable по умолчанию.** Используйте `ref` и `mutable` только когда это осознанно необходимо:

```ocaml
(* Хорошо --- иммутабельно *)
let sum lst = List.fold_left ( + ) 0 lst

(* Допустимо --- ref для локальной оптимизации *)
let sum_imperative lst =
  let acc = ref 0 in
  List.iter (fun x -> acc := !acc + x) lst;
  !acc

(* mutable --- когда семантика требует изменяемости *)
type counter = { mutable count : int }

let increment c = c.count <- c.count + 1
```

### Форматирование

Основные правила форматирования кода:

- **Максимум 80--90 колонок** в строке.
- **Без табов** --- только пробелы.
- **Пробелы вокруг операторов**, после запятых и `;`:

```ocaml
(* Хорошо *)
let x = a + b
let pair = (1, 2, 3)
let record = { name = "Alice"; age = 30 }

(* Плохо *)
let x=a+b
let pair = (1,2,3)
let record = {name="Alice";age=30}
```

- **Кортежи в скобках:**

```ocaml
(* Хорошо *)
let point = (1, 2, 3)

(* Плохо *)
let point = 1, 2, 3
```

- **Пробел вокруг `::`:**

```ocaml
(* Хорошо *)
let lst = x :: rest

(* Плохо *)
let lst = x::rest
```

- **Функции в пределах одного экрана** (~70 строк). Если функция длиннее --- разбейте на вспомогательные.

Для автоматического форматирования используйте **ocamlformat** --- он обеспечивает единый стиль во всём проекте:

```text
$ opam install ocamlformat
$ echo 'version = 0.27.0' > .ocamlformat
$ dune fmt
```

## Dune в деталях

Мы уже познакомились с базовой структурой Dune-проекта. Теперь рассмотрим возможности системы сборки подробнее.

### Структура проекта

**`dune-project`** --- корневой файл проекта. Он обязателен и определяет версию языка конфигурации:

```dune
(lang dune 3.0)
(name my_project)
```

Dune поддерживает три основных компонента:

- **`library`** --- библиотека, набор модулей для переиспользования:

```dune
(library
 (name my_lib)
 (public_name my-project.lib)
 (libraries str unix))
```

- **`executable`** --- исполняемый файл:

```dune
(executable
 (name main)
 (public_name my-tool)
 (libraries my_lib cmdliner))
```

- **`test`** --- тесты:

```dune
(test
 (name test_main)
 (libraries my_lib alcotest))
```

**`name` vs `public_name`:** `name` --- внутреннее имя для ссылок внутри проекта, `public_name` --- имя для публикации в opam. Если `public_name` не указан, компонент остаётся приватным.

### Правила и действия

Dune позволяет определять произвольные правила сборки через `rule`. Каждое правило описывает, как из входных файлов (`deps`) получить выходные (`target`):

```dune
(rule
 (target a.out)
 (deps main.ml)
 (action (run ocamlopt main.ml)))
```

Действие `action` может содержать различные команды: `run`, `echo`, `cat`, `copy`, `with-stdout-to` и другие.

### Встраивание ресурсов

Dune позволяет встраивать содержимое файлов в OCaml-код на этапе сборки. Это полезно для CSS, SQL-запросов, шаблонов и прочих ресурсов:

```dune
(rule
 (with-stdout-to css.ml
  (progn
   (echo "let css = {|")
   (cat resources/site.css)
   (echo "|}"))))
```

Эта конструкция создаёт файл `css.ml` с содержимым:

```ocaml
let css = {|
/* содержимое resources/site.css */
body { margin: 0; }
|}
```

Здесь `{| ... |}` --- синтаксис quoted string в OCaml, который позволяет включать произвольный текст без экранирования.

### Платформозависимый код

Для кросс-платформенных библиотек Dune поддерживает условный выбор реализации через `select`:

```dune
(library
 (public_name crypt)
 (libraries
  (select ffi.ml from
   (if_is_linux_or_freebsd -> ffi.posix.extended.ml))))
```

Конструкция `select ... from` выбирает конкретный файл реализации в зависимости от платформы или доступных библиотек. Это позволяет поддерживать разные реализации для Linux, macOS, Windows в одной кодовой базе.

### Полезные флаги и команды

**Авто-open модуля** через переменные окружения:

```dune
(env
 (_
  (flags (:standard -open Base))))
```

Флаг `-open Base` автоматически открывает модуль `Base` во всех файлах. Это часто используется с альтернативными стандартными библиотеками (Base, Core).

**Watch mode для LSP** --- Dune может работать в режиме наблюдения, перекомпилируя проект при изменении файлов:

```text
$ dune build @check -w
```

Это полезно для ускорения работы LSP-сервера --- ошибки обновляются в реальном времени.

**Release-сборка:**

```text
$ dune build --profile release
```

Профиль `release` включает оптимизации и отключает отладочную информацию.

**Конвенции public names:**

- Точки обозначают поддиректорию внутри пакета: `lwt.unix` --- это библиотека `unix` внутри пакета `lwt`.
- Дефисы обозначают отдельный пакет: `cohttp-eio` --- самостоятельный пакет, зависящий от `cohttp`.

### Зависимости в тестах

Если тесты используют внешние файлы (данные, фикстуры), их нужно явно объявить в `deps`:

```dune
(test
 (name test_demo)
 (deps data.test.txt))
```

Без объявления в `deps` Dune не скопирует файл в директорию сборки, и тест не сможет его найти. Путь к файлу в коде теста будет относительным:

```ocaml
let data = In_channel.with_open_text "data.test.txt" In_channel.input_all
```

## ocamlformat --- автоматическое форматирование

[ocamlformat](https://github.com/ocaml-ppx/ocamlformat) --- автоформаттер для OCaml. Он обеспечивает единообразный стиль кода, устраняя споры о форматировании в команде.

### Настройка

Создайте файл `.ocamlformat` в корне проекта:

```text
version = 0.27.0
```

Минимально необходим только номер версии --- это гарантирует, что все участники проекта используют одни и те же правила форматирования. Дополнительные настройки можно добавить по необходимости:

```text
version = 0.27.0
margin = 90
```

```admonish warning title="Важно"
Файл `.ocamlformat` обязателен. Без него ocamlformat откажется работать. Это защита от случайного переформатирования файлов без согласованных настроек.
```

### Использование

Форматирование через Dune:

```text
$ dune fmt
```

Эта команда проверяет форматирование всех файлов и показывает diff. Чтобы применить изменения:

```text
$ dune promote
```

Или в один шаг --- форматировать и сразу применить:

```text
$ dune fmt 2>/dev/null; dune promote
```

```admonish tip title="Для Python-разработчиков"
`ocamlformat` --- это аналог `black` для Python. Как и `black`, ocamlformat намеренно предоставляет мало настроек: единый стиль для всей экосистемы.
```

### Интеграция с редактором

Если установлен `ocaml-lsp-server`, форматирование работает через LSP: редактор отправляет запрос, LSP вызывает ocamlformat. В VS Code форматирование срабатывает при сохранении файла (если включено `Format on Save`).

## Линтинг --- предупреждения компилятора

В OCaml нет отдельного линтера, как ESLint для JavaScript или ruff для Python. Вместо этого **компилятор сам выполняет роль линтера** через систему предупреждений (warnings).

### Предупреждения как линтер

Компилятор OCaml имеет более 70 предупреждений. Некоторые из самых полезных:

| Номер | Описание |
|-------|----------|
| 8 | Неполное сопоставление с образцом |
| 11 | Неиспользуемая привязка match |
| 26 | Неиспользуемый модуль |
| 27 | Неиспользуемая переменная |
| 32 | Неиспользуемое значение |
| 39 | Неиспользуемая декларация в .mli |

### `-warn-error` --- предупреждения как ошибки

Чтобы превратить предупреждения в ошибки компиляции, используйте `-warn-error`. Это полезно в CI для поддержания чистоты кода:

```dune
(env
 (dev
  (flags (:standard -warn-error -a+8+26+27+32))))
```

Здесь `-a` отключает все warn-error, а `+8+26+27+32` включает конкретные предупреждения как ошибки.

### Аттрибуты `@warning`

Для точечного управления предупреждениями используйте аттрибуты:

```ocaml
(* Подавить предупреждение о неиспользуемой переменной *)
let _unused = 42

(* Или через аттрибут *)
let[@warning "-32"] helper x = x + 1
```

Конвенция: неиспользуемые привязки именуются с подчёркиванием `_` --- это подавляет предупреждение 27.

## Настройка редактора и LSP

### ocaml-lsp-server

[ocaml-lsp-server](https://github.com/ocaml/ocaml-lsp) обеспечивает:

- **Автодополнение** --- подсказки имён модулей, функций, типов.
- **Подсказки типов** --- при наведении на выражение показывается его тип.
- **Переход к определению** --- jump-to-definition для любого идентификатора.
- **Поиск ссылок** --- все места использования функции.
- **Форматирование** --- через ocamlformat.
- **Диагностика** --- ошибки компиляции в реальном времени.

### VS Code

1. Установите расширение [OCaml Platform](https://marketplace.visualstudio.com/items?itemName=ocamllabs.ocaml-platform).
2. Откройте директорию с `dune-project` (не корень монорепозитория!).
3. Расширение автоматически найдёт `ocamllsp` и начнёт работу.

Полезные горячие клавиши:

| Действие | macOS | Linux/Windows |
|----------|-------|---------------|
| Перейти к определению | `Cmd+Click` | `Ctrl+Click` |
| Показать тип | `Cmd+K, Cmd+I` | `Ctrl+K, Ctrl+I` |
| Найти все ссылки | `Shift+F12` | `Shift+F12` |
| Переименовать | `F2` | `F2` |

### Neovim

Для Neovim используйте `nvim-lspconfig`:

```lua
require('lspconfig').ocamllsp.setup {}
```

Убедитесь, что `ocamllsp` доступен в `$PATH` (через `eval $(opam env)`).

### Рекомендации

```admonish tip title="Совет"
Открывайте в редакторе директорию конкретной главы (например, `exercises/chapter02`), а не корень репозитория. Так LSP корректно найдёт `dune-project` и сможет выводить типы.
```

Для ускорения обратной связи запустите Dune в watch-режиме в отдельном терминале:

```text
$ dune build @check -w
```

Это обновляет `.merlin`-файлы и кэш сборки в реальном времени.

## opam --- управление пакетами

Мы уже установили opam и создали switch. Рассмотрим дополнительные возможности.

### Switch --- изолированные окружения

Каждый switch содержит свою версию компилятора и набор пакетов:

```text
$ opam switch list
#   switch    compiler    description
→   5.4.0     ocaml.5.4.0 5.4.0

$ opam switch create my-project 5.4.0
$ eval $(opam env)
```

Это похоже на `venv` в Python или `nvm` в Node.js.

### Установка и поиск пакетов

```text
$ opam install dream yojson              # установить пакеты
$ opam list --installed                  # показать установленные
$ opam search json                       # найти пакеты по ключевому слову
$ opam info yojson                       # подробная информация о пакете
```

### Pin --- локальные пакеты

Для разработки с локальной версией библиотеки:

```text
$ opam pin add my-lib ./path/to/lib      # привязать к локальному пути
$ opam pin remove my-lib                 # убрать привязку
```

Pin позволяет работать с форками или ещё не опубликованными версиями.

## odoc --- генерация документации

[odoc](https://ocaml.github.io/odoc/) генерирует HTML-документацию из комментариев в коде:

```ocaml
(** [greet name] возвращает приветствие для [name].

    Пример:
    {[
      greet "OCaml" = "Привет, OCaml!"
    ]}
*)
val greet : string -> string
```

Генерация:

```text
$ opam install odoc
$ dune build @doc
$ open _build/default/_doc/_html/index.html
```

Документация извлекается из `.mli`-файлов (или `.ml`, если `.mli` отсутствует). Формат комментариев --- **odoc markup**, похожий на Javadoc.

## Заключение

В этой главе мы:

- Установили opam, Dune и настроили редактор.
- Познакомились со структурой проекта: `dune-project`, `dune`-файлы, модули.
- Научились пользоваться utop: вычислять выражения, узнавать типы.
- Изучили базовые типы OCaml: `int`, `float`, `string`, `bool`, `char`, `unit`.
- Разобрали отдельные операторы для `float` и `let`-привязки.
- Познакомились с тестированием через Alcotest.
- Изучили конвенции и гайдлайны OCaml: именование, модули, pattern matching, обработку ошибок и форматирование.
- Разобрали систему сборки Dune в деталях: структуру проекта, правила, встраивание ресурсов и полезные команды.
- Настроили инструменты: ocamlformat, LSP, предупреждения компилятора.
- Познакомились с opam (switches, pin) и odoc.
- Решили первые упражнения.

В следующих главах будет больше упражнений, и они станут сложнее. Если вы застрянете, загляните в раздел ["Где искать помощь"](chapter01.md#где-искать-помощь) из первой главы.

Когда решите все упражнения, можете сравнить свои ответы с эталонными в `no-peeking/solutions.ml`. Но, пожалуйста, не подсматривайте без честной попытки решить самостоятельно.
