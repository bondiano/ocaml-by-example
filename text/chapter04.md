# Функции и записи

## Цели главы

В этой главе мы построим адресную книгу. Через неё разберём два строительных блока OCaml — функции и записи (records).

Темы главы:

- Определение типов с помощью `type`.
- Записи (records) — именованные поля в типах.
- Функциональное обновление записей (`{ r with field = value }`).
- Мутабельные поля записей.
- Каррирование (currying) и частичное применение (partial application).
- Именованные аргументы (labeled arguments) — `~label`.
- Опциональные аргументы (optional arguments) — `?opt`.
- Оператор конвейера (pipe operator) `|>`.
- Тип `option` для представления необязательных значений.

## Подготовка проекта

Код этой главы находится в `exercises/chapter04`. Основной модуль — `lib/address_book.ml`. Соберите проект:

```text
$ cd exercises/chapter04
$ dune build
```

Если сборка прошла без ошибок, можно запустить тесты:

```text
$ dune runtest
```

## Базовые типы и аннотации типов

Прежде чем определять собственные типы, вспомним базовые типы OCaml и то, как работают аннотации типов. В utop можно узнать тип выражения:

```text
# 42;;
- : int = 42

# 3.14;;
- : float = 3.14

# "hello";;
- : string = "hello"

# true;;
- : bool = true

# 'a';;
- : char = 'a'
```

OCaml выводит типы автоматически, но иногда полезно указать тип явно. Аннотации записываются через двоеточие:

```ocaml
let x : int = 42
let greeting : string = "hello"
```

В сигнатурах функций аннотации типов служат документацией и защитой от ошибок:

```ocaml
let add (x : int) (y : int) : int = x + y
```

Здесь мы явно указали типы параметров и возвращаемого значения. Чаще всего OCaml выведет типы сам, но явные аннотации полезны в публичных функциях.

## Определение типов

В OCaml ключевое слово `type` используется для определения новых типов.

### Синонимы типов

Простейший случай — синоним (type alias), альтернативное имя для существующего типа:

```ocaml
type address_book = entry list
```

`address_book` и `entry list` — один и тот же тип. Синонимы полезны как документация: `address_book` читается лучше, чем `entry list`.

### Записи

Записи (records) — типы с именованными полями. Определим тип адреса:

```ocaml
type address = {
  street : string;
  city   : string;
  state  : string;
}
```

Здесь `address` — тип с тремя полями типа `string`. Точка с запятой разделяет поля.

Определим тип записи адресной книги:

```ocaml
type entry = {
  first_name : string;
  last_name  : string;
  address    : address;
}
```

Записи могут содержать другие записи — поле `address` имеет тип `address`.

Обратите внимание на стиль именования: OCaml использует `snake_case` для имён полей и типов (в отличие от `camelCase` в Haskell и PureScript).

```admonish info title="Подробнее"
Детальное описание записей и пользовательских типов: [Real World OCaml, глава «Records»](https://dev.realworldocaml.org/records.html)
```

### Синоним для адресной книги

```ocaml
type address_book = entry list
```

## Работа с записями

### Создание записей

Запись создаётся перечислением всех полей:

```text
# let addr = { street = "ул. Пушкина, 10"; city = "Москва"; state = "Москва" };;
val addr : address = {street = "ул. Пушкина, 10"; city = "Москва"; state = "Москва"}
```

Все поля обязательны — пропустить поле нельзя (это ошибка компиляции).

### Доступ к полям

К полям записи обращаемся через точку:

```text
# addr.street;;
- : string = "ул. Пушкина, 10"

# addr.city;;
- : string = "Москва"
```

Для вложенных записей используем цепочку точек:

```text
# let e = { first_name = "Иван"; last_name = "Петров"; address = addr };;
# e.address.street;;
- : string = "ул. Пушкина, 10"
```

### Сопоставление с образцом

Записи можно деструктурировать через сопоставление с образцом (pattern matching):

```ocaml
let show_address { street; city; state } =
  street ^ ", " ^ city ^ ", " ^ state
```

Здесь `{ street; city; state }` — образец, который извлекает поля в одноимённые переменные. Это компактнее, чем `addr.street ^ ", " ^ addr.city ^ ", " ^ addr.state` с явным доступом через точку. Компилятор определяет тип записи по именам полей автоматически.

Можно также извлечь только нужные поля, игнорируя остальные:

```ocaml
let city_of { city; _ } = city
```

Символ `_` означает «остальные поля нас не интересуют» — без него компилятор может выдать предупреждение о неполном образце.

## Функциональное обновление записей

Записи в OCaml по умолчанию иммутабельны — мы не изменяем существующую запись, а создаём новую с изменёнными полями. Для этого используется синтаксис `with`:

```text
# let addr2 = { addr with city = "Санкт-Петербург" };;
val addr2 : address = {street = "ул. Пушкина, 10"; city = "Санкт-Петербург"; state = "Москва"}

# addr.city;;
- : string = "Москва"
```

Выражение `{ addr with city = "Санкт-Петербург" }` создаёт копию `addr`, в которой поле `city` заменено на новое значение. Остальные поля (`street`, `state`) копируются из оригинала без изменений. Исходный `addr` не изменяется.

Можно обновить несколько полей одновременно:

```ocaml
let addr3 = { addr with city = "Казань"; state = "Татарстан" }
```

## Мутабельные поля записей

По умолчанию поля записей иммутабельны. Однако OCaml позволяет пометить отдельные поля как мутабельные (mutable) ключевым словом `mutable`:

```ocaml
type counter = {
  name : string;
  mutable value : int;
}
```

Мутабельное поле можно изменить «на месте» оператором `<-`:

```text
# let c = { name = "clicks"; value = 0 };;
# c.value <- c.value + 1;;
- : unit = ()
# c.value;;
- : int = 1
```

Оператор `<-` присваивает новое значение полю напрямую, изменяя существующую запись. Он возвращает `unit` — «ничего полезного». Здесь `c` связано с одной и той же записью в памяти, поэтому последующий `c.value` отражает изменение.

Мутабельные поля полезны для оптимизации, но в идиоматическом OCaml предпочитают функциональное обновление. В нашей адресной книге мутабельные поля не нужны — мы будем использовать иммутабельный подход.

## Функции

### Определение и типы

Функции в OCaml — значения первого класса (first-class values). Их можно присваивать переменным, передавать как аргументы и возвращать как результат.

Определение функции:

```ocaml
let add x y = x + y
```

Тип этой функции — `int -> int -> int`. Стрелка `->` правоассоциативна, поэтому тип читается как `int -> (int -> int)`: функция принимает `int` и возвращает функцию `int -> int`.

Анонимные функции (лямбды) записываются через `fun`:

```ocaml
let add = fun x y -> x + y
```

Это эквивалентная запись. Ключевое слово `fun` создаёт анонимную функцию.

### Применение функций

Функция применяется к аргументам через пробел:

```text
# add 3 5;;
- : int = 8

# String.length "hello";;
- : int = 5
```

Скобки нужны только для группировки:

```text
# add (add 1 2) (add 3 4);;
- : int = 10
```

## Каррирование и частичное применение

Все функции в OCaml каррированы (curried): функция нескольких аргументов — это функция, которая принимает первый аргумент и возвращает новую функцию, ожидающую остальные.

Рассмотрим `add`:

```text
# let add x y = x + y;;
val add : int -> int -> int = <fun>

# let add_five = add 5;;
val add_five : int -> int = <fun>

# add_five 3;;
- : int = 8
```

`add_five` — это новая функция, которая прибавляет 5 к своему аргументу. Мы получили её, передав `add` только один аргумент из двух. Этот механизм называется **частичным применением** (partial application).

```admonish tip title="Для Python/TS-разработчиков"
Каррирование в OCaml позволяет создавать новые функции из существующих: `let add5 = add 5`. В Python для этого используют `functools.partial(add, 5)` или лямбды `lambda b: add(5, b)`. В TypeScript можно написать `const add5 = (b: number) => add(5, b)`. В OCaml каррирование встроено в язык — любая функция автоматически каррирована.
```

Частичное применение — мощный инструмент. Например, `List.map (( * ) 2)` удвоит каждый элемент списка:

```text
# List.map (( * ) 2) [1; 2; 3; 4];;
- : int list = [2; 4; 6; 8]
```

Здесь `( * ) 2` — частичное применение оператора умножения: инфиксный `*` записан в скобках как обычная функция типа `int -> int -> int`, к которой применён первый аргумент `2`. Результат — функция `int -> int`, которую `List.map` применяет к каждому элементу списка.

## Именованные аргументы

OCaml поддерживает именованные аргументы (labeled arguments) — уникальную особенность, которой нет в Haskell и PureScript. Именованный аргумент обозначается тильдой `~`:

```ocaml
let create_entry ~first_name ~last_name ~address =
  { first_name; last_name; address }
```

При вызове именованные аргументы можно передавать **в любом порядке**:

```text
# create_entry ~first_name:"Иван" ~last_name:"Петров" ~address:addr;;
# create_entry ~last_name:"Петров" ~first_name:"Иван" ~address:addr;;
```

Оба вызова эквивалентны. Это особенно удобно для функций с большим числом параметров, когда порядок легко перепутать.

### Сокращённая запись

Если переменная имеет то же имя, что и метка, можно использовать сокращение:

```ocaml
let first_name = "Иван" in
let last_name = "Петров" in
create_entry ~first_name ~last_name ~address:addr
```

Вместо `~first_name:first_name` достаточно написать `~first_name`.

### Именованные аргументы в типах

Тип функции с именованными аргументами содержит метки:

```text
# let greet ~greeting ~name = greeting ^ ", " ^ name ^ "!";;
val greet : greeting:string -> name:string -> string = <fun>
```

Метки становятся частью типа, что повышает читаемость сигнатур.

### Частичное применение с именованными аргументами

Именованные аргументы можно частично применять в любом порядке:

```text
# let greet_hello = greet ~greeting:"Привет";;
val greet_hello : name:string -> string = <fun>

# greet_hello ~name:"Анна";;
- : string = "Привет, Анна!"
```

`greet_hello` — это новая функция, специализированная для приветствия словом «Привет». Тип `name:string -> string` показывает, что метка `greeting:` уже применена, и осталось передать только `name`. Именованные аргументы можно применять в любом порядке, что делает частичное применение гибким.

## Опциональные аргументы

Опциональные аргументы (optional arguments) обозначаются знаком вопроса `?`. Они могут быть опущены при вызове — в этом случае используется значение по умолчанию:

```ocaml
let greet ?(greeting = "Здравствуйте") name =
  greeting ^ ", " ^ name ^ "!"
```

```text
# greet "Анна";;
- : string = "Здравствуйте, Анна!"

# greet ~greeting:"Привет" "Анна";;
- : string = "Привет, Анна!"
```

### Тип опциональных аргументов

Внутри функции опциональный аргумент имеет тип `option`. Если значение по умолчанию не указано, аргумент приходит как `Some x` или `None`:

```ocaml
let greet ?greeting name =
  let g = match greeting with
    | Some s -> s
    | None -> "Здравствуйте"
  in
  g ^ ", " ^ name ^ "!"
```

Когда вызываем `greet "Анна"` — аргумент `greeting` имеет значение `None`, и сопоставление с образцом выбирает строку по умолчанию. При вызове `greet ~greeting:"Привет" "Анна"` — аргумент будет `Some "Привет"`, и `s` извлекается из обёртки. Явный `match` с `option` полезен, когда нужна более сложная логика, чем просто значение по умолчанию.

### Правила стирания

Есть важное правило: опциональный аргумент стирается (erased), когда применяется следующий за ним **позиционный** аргумент. Поэтому опциональные аргументы должны стоять перед позиционными:

```ocaml
(* Правильно: опциональный перед позиционным *)
let greet ?(greeting = "Привет") name = greeting ^ ", " ^ name

(* Плохо: опциональный аргумент последний — компилятор предупредит *)
let greet name ?(greeting = "Привет") = greeting ^ ", " ^ name
```

Если все аргументы после опционального тоже именованные, стирание может не произойти. В таких случаях передайте `()` как последний аргумент:

```ocaml
let configure ?(verbose = false) ?(debug = false) () =
  if verbose then print_endline "Verbose mode";
  if debug then print_endline "Debug mode"
```

Здесь `()` — финальный позиционный аргумент типа `unit`. Он служит «триггером» для стирания опциональных аргументов: когда вызываем `configure ()` или `configure ~verbose:true ()`, компилятор понимает, что все аргументы переданы, и вызывает функцию. Без него `configure` при частичном применении возвращала бы функцию, а не выполнялась.

## Оператор конвейера `|>`

В Haskell для избавления от скобок используют операторы `($)` и `(.)`. В OCaml им соответствует встроенный оператор конвейера (pipe operator) `|>`:

```ocaml
let ( |> ) x f = f x
```

Это определение оператора `|>`: он принимает значение `x` и функцию `f`, и возвращает `f x`. Запись оператора в скобках `( |> )` — стандартный способ определить инфиксный оператор как обычную функцию. На практике `|>` встроен в язык и не требует определения — это просто иллюстрация. Он передаёт значение слева как аргумент функции справа. Сравните:

```ocaml
(* Вложенные вызовы: *)
String.uppercase_ascii (String.trim "  hello  ")

(* С конвейером: *)
"  hello  " |> String.trim |> String.uppercase_ascii
```

Конвейер читается слева направо, как последовательность шагов: «взять строку, обрезать пробелы, перевести в верхний регистр». Это идиоматический стиль OCaml.

```admonish tip title="Для Python/TS-разработчиков"
Оператор `|>` похож на цепочку методов в Python и TypeScript. Например, `"  hello  " |> String.trim |> String.uppercase_ascii` — аналог `"  hello  ".strip().upper()` в Python или `"  hello  ".trim().toUpperCase()` в TypeScript. Разница в том, что `|>` работает с любыми функциями, а не только с методами объекта.
```

### Конвейер и частичное применение

Конвейер хорошо сочетается с частичным применением:

```text
# [1; 2; 3; 4; 5]
  |> List.filter (fun x -> x mod 2 = 0)
  |> List.map (( * ) 10);;
- : int list = [20; 40]
```

Сначала фильтруем чётные числа, затем умножаем каждое на 10. Каждый шаг — частично применённая функция.

### `|>` вместо `(.)` и `($)`

В Haskell вы бы написали:

```haskell
length . filter even $ [1..10]
```

В OCaml это же выражение записывается с конвейером:

```ocaml
[1; 2; 3; 4; 5; 6; 7; 8; 9; 10]
|> List.filter (fun x -> x mod 2 = 0)
|> List.length
```

Конвейер заменяет и `($)` (применение), и `(.)` (композицию), поскольку цепочка `|>` одновременно строит конвейер обработки и применяет его к данным.

Композиция функций в OCaml тоже возможна через `Fun.compose` или оператор `@@` (применение с правоассоциативным приоритетом, аналог `$`):

```ocaml
(* @@ — аналог $ из Haskell *)
print_endline @@ String.uppercase_ascii @@ String.trim "  hello  "
```

Оператор `@@` означает «применить функцию слева к значению справа», читается справа налево: сначала `String.trim "  hello  "` даёт `"hello"`, затем `String.uppercase_ascii "hello"` даёт `"HELLO"`, затем `print_endline "HELLO"` выводит строку. Это позволяет избежать вложенных скобок.

Но `|>` используется значительно чаще, поскольку он лучше читается и лучше работает с выводом типов.

## Тип `option`

`option` — стандартный тип OCaml для представления значения, которого может не быть (аналог `Maybe` в Haskell):

```ocaml
type 'a option = None | Some of 'a
```

Здесь `'a` — параметр типа (type parameter): `option` полиморфен и работает с любым типом. `int option` — опциональное целое, `string option` — опциональная строка. Конструкторы — это `None` (значения нет) и `Some of 'a` (значение завёрнуто внутри).

- `None` — значения нет (безопасный аналог `null`).
- `Some x` — значение `x` есть.

```text
# Some 42;;
- : int option = Some 42

# None;;
- : 'a option = None

# List.find_opt (fun x -> x > 3) [1; 2; 3; 4; 5];;
- : int option = Some 4

# List.find_opt (fun x -> x > 10) [1; 2; 3; 4; 5];;
- : int option = None
```

Обратите внимание: `None` имеет тип `'a option` с полиморфной переменной — компилятор не может вывести конкретный тип без дополнительного контекста. В конкретном использовании (например, `List.find_opt` для `int`-списка) тип уточняется до `int option`. Функция `List.find_opt` ищет первый элемент, удовлетворяющий предикату, и возвращает `option`. Это безопаснее, чем `List.find`, которая бросает исключение `Not_found`.

```admonish tip title="Для Python/TS-разработчиков"
`option` заменяет `None`/`null`/`undefined`, но безопасно. В Python `dict.get("key")` возвращает `None`, и забыть проверить — легко. В TypeScript `T | undefined` требует проверки, но только с `strictNullChecks`. В OCaml `option` — это вариантный тип: компилятор **не позволит** использовать значение без обработки случая `None`. Это исключает целый класс ошибок `NoneType has no attribute` / `Cannot read property of undefined`.
```

## Проект: адресная книга

Теперь соберём все концепции вместе, строя адресную книгу шаг за шагом. Весь код находится в `lib/address_book.ml`.

### Типы

```ocaml
type address = {
  street : string;
  city   : string;
  state  : string;
}

type entry = {
  first_name : string;
  last_name  : string;
  address    : address;
}

type address_book = entry list
```

### Форматирование записей

Напишем функции для форматирования записей в строку. Оператор `^` — конкатенация строк:

```ocaml
let show_address addr =
  addr.street ^ ", " ^ addr.city ^ ", " ^ addr.state

let show_entry entry =
  entry.last_name ^ ", " ^ entry.first_name ^ ": "
  ^ show_address entry.address
```

Проверим в utop:

```text
# let addr = { street = "ул. Пушкина, 10"; city = "Москва"; state = "Москва" };;
# show_address addr;;
- : string = "ул. Пушкина, 10, Москва, Москва"

# let entry = { first_name = "Иван"; last_name = "Петров"; address = addr };;
# show_entry entry;;
- : string = "Петров, Иван: ул. Пушкина, 10, Москва, Москва"
```

### Пустая книга и добавление записей

Пустая адресная книга — пустой список:

```ocaml
let empty_book : address_book = []
```

Для добавления записи помещаем её в начало списка оператором `::` (cons):

```ocaml
let insert_entry entry book = entry :: book
```

Попробуем:

```text
# let book = insert_entry entry empty_book;;
# List.length book;;
- : int = 1

# let addr2 = { street = "Невский пр., 28"; city = "Санкт-Петербург"; state = "Санкт-Петербург" };;
# let entry2 = { first_name = "Анна"; last_name = "Сидорова"; address = addr2 };;
# let book = insert_entry entry2 book;;
# List.length book;;
- : int = 2
```

Обратите внимание: `insert_entry` не изменяет существующую книгу, а возвращает новую. Данные иммутабельны.

### Поиск в адресной книге

Реализуем функцию поиска по имени и фамилии. Используем `List.find_opt`, которая возвращает `option`:

```ocaml
let find_entry first last book =
  book |> List.find_opt (fun entry ->
    entry.first_name = first && entry.last_name = last
  )
```

Разберём по частям:

1. `book |> List.find_opt (...)` — конвейер: передаём книгу в `List.find_opt`.
2. `List.find_opt` принимает предикат (функцию `entry -> bool`) и список. Возвращает `Some entry` для первого совпадения или `None`.
3. Анонимная функция `fun entry -> ...` сравнивает имя и фамилию.

Проверим:

```text
# find_entry "Иван" "Петров" book;;
- : entry option = Some {first_name = "Иван"; last_name = "Петров"; ...}

# find_entry "Пётр" "Иванов" book;;
- : entry option = None
```

Можно записать то же самое без конвейера:

```ocaml
let find_entry first last book =
  List.find_opt (fun entry ->
    entry.first_name = first && entry.last_name = last
  ) book
```

Обе записи эквивалентны. Обратите внимание: в версии без конвейера `book` передаётся последним позиционным аргументом — это стандартный OCaml-стиль, при котором «данные» идут последними, чтобы упростить частичное применение. Выбор между стилями — дело вкуса, но конвейер удобнее при цепочке нескольких операций.

## Упражнения

Решения пишите в `test/my_solutions.ml`. Проверяйте: `dune runtest`.

1. **(Среднее)** Реализуйте функцию `find_entry_by_street`, которая находит запись по названию улицы.

    ```ocaml
    val find_entry_by_street : string -> entry list -> entry option
    ```

    *Подсказка:* адаптируйте `find_entry` — измените предикат. Для доступа к улице: `entry.address.street`.

2. **(Среднее)** Реализуйте функцию `entry_exists` с именованными аргументами, которая проверяет, есть ли запись с данным именем и фамилией в адресной книге.

    ```ocaml
    val entry_exists : first_name:string -> last_name:string -> entry list -> bool
    ```

    Обратите внимание: `first_name` и `last_name` — именованные аргументы (с `~`), а список — позиционный.

    *Подсказка:* используйте `List.exists`.

3. **(Сложное)** Реализуйте функцию `remove_duplicates`, которая удаляет дубликаты из адресной книги. Дубликатами считаются записи с одинаковыми именем и фамилией (поле `address` игнорируется). Из группы дубликатов сохраняется первый (ближайший к началу списка).

    ```ocaml
    val remove_duplicates : entry list -> entry list
    ```

    *Подсказка:* используйте `List.fold_left` или вспомогательную рекурсивную функцию. Стандартной функции `nubBy` (как в Haskell) в OCaml нет, но её несложно написать.

## Заключение

В этой главе мы определили типы данных с записями, разобрали каррирование и частичное применение, познакомились с именованными и опциональными аргументами, освоили оператор конвейера `|>` и тип `option`.

Следующая глава — алгебраические типы данных и сопоставление с образцом.
