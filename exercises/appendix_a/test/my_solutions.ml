(** Здесь вы пишете решения упражнений.

    Каждая функция — это кусочек логики реальной игры Арканоид.
    После реализации запустите [dune test], а затем [dune exec ./bin/main.exe]
    чтобы увидеть свой код в действии. *)

open Appendix_a.Game

(** Упражнение 1. Двигаем паддл.

    Прибавьте [dx] к [st.paddle.x], затем ограничьте координату так,
    чтобы паддл не выходил за края экрана:
    диапазон [0; st.screen_w - st.paddle.w].
    Верните обновлённое состояние с новым [paddle.x]. *)
let move_paddle (_st : state) (_dx : float) : state =
  failwith "todo"

(** Упражнение 2. Шаг мяча.

    Вычислите новую позицию: [pos + vel].
    - Если новый [x ± radius] выходит за левую или правую стену — инвертируйте [vel.x].
    - Если новый [y - radius < 0] (касается потолка) — инвертируйте [vel.y].
    - Если новый [y + radius > screen_h] (улетел вниз) — [fell = true].

    Верните [(новый_мяч, fell)].
    Подсказка: используйте [vec2_add] из библиотеки. *)
let step_ball (_st : state) : ball * bool =
  failwith "todo"

(** Упражнение 3. Паддл отбивает мяч.

    Если мяч касается паддла И летит вниз ([vel.y > 0.0]):
    - верните [Some new_ball] где [new_vel.y = -. |vel.y|].
    Иначе верните [None].

    Используйте [rect_hits_ball] из библиотеки:
    {[ rect_hits_ball ~bx:p.x ~by:p.y ~bw:p.w ~bh:p.h st.ball ]}

    Подсказка: не трогайте [vel.x] — паддл отбивает только по вертикали. *)
let paddle_deflects_ball (_st : state) : ball option =
  failwith "todo"

(** Упражнение 4. Убираем разбитые кирпичи.

    Для каждого кирпича в [st.bricks] проверьте столкновение с [st.ball]
    через [rect_hits_ball ~bx:b.x ~by:b.y ~bw:b.w ~bh:b.h st.ball].
    - Задетые кирпичи уберите из списка.
    - Суммируйте их [points].
    Верните [(оставшиеся_кирпичи, сумма_очков)]. *)
let remove_hit_bricks (_st : state) : brick list * int =
  failwith "todo"

(** Упражнение 5 (сложное). Полный шаг игры.

    Используя функции выше, реализуйте один игровой кадр:
    1. Если [st.phase <> Playing] — вернуть состояние без изменений.
    2. Двинуть паддл на [dx] (используйте [move_paddle]).
    3. Двинуть мяч (используйте [step_ball]).
    4. Применить отражение от паддла (используйте [paddle_deflects_ball]).
    5. Убрать разбитые кирпичи, прибавить очки (используйте [remove_hit_bricks]).
    6. Если мяч упал: уменьшить [lives].
       При [lives <= 0] установить [phase = Lost], иначе сбросить мяч в начало
       (используйте [initial_state] чтобы взять позицию мяча).
    7. Если [bricks = []] — установить [phase = Won]. *)
let step_game (_st : state) (_dx : float) : state =
  failwith "todo"
